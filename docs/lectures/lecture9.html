<!DOCTYPE html>
<html lang="en"><head>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/tabby.min.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-985aa47af68dae11cd4d235c71fb941e.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.7.27">

  <title>EGH445 Modern Control – lecture9</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../site_libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="../site_libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #003b4f; background-color: #f1f3f5; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #003b4f; } /* Normal */
    code span.al { color: #ad0000; } /* Alert */
    code span.an { color: #5e5e5e; } /* Annotation */
    code span.at { color: #657422; } /* Attribute */
    code span.bn { color: #ad0000; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #003b4f; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #20794d; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #5e5e5e; } /* Comment */
    code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
    code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
    code span.dt { color: #ad0000; } /* DataType */
    code span.dv { color: #ad0000; } /* DecVal */
    code span.er { color: #ad0000; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #ad0000; } /* Float */
    code span.fu { color: #4758ab; } /* Function */
    code span.im { color: #00769e; } /* Import */
    code span.in { color: #5e5e5e; } /* Information */
    code span.kw { color: #003b4f; font-weight: bold; } /* Keyword */
    code span.op { color: #5e5e5e; } /* Operator */
    code span.ot { color: #003b4f; } /* Other */
    code span.pp { color: #ad0000; } /* Preprocessor */
    code span.sc { color: #5e5e5e; } /* SpecialChar */
    code span.ss { color: #20794d; } /* SpecialString */
    code span.st { color: #20794d; } /* String */
    code span.va { color: #111111; } /* Variable */
    code span.vs { color: #20794d; } /* VerbatimString */
    code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../site_libs/revealjs/dist/theme/quarto-2ece5c28b4f67afd026fc65ac1fbbec1.css">
  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">
  <link href="../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-chalkboard/font-awesome/css/all.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-chalkboard/style.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
  </head><body class="quarto-light"><div class="slide-header">

    <div class="main-header-content">

      <span id="header-left">Lecture Title</span> <span id="header-right">Section</span>      </div>

    <div class="sub-header-content" id="sub-header-container">

      <span id="sub-header-title">Slide Title</span> </div>

  </div>


  <div class="reveal">
    <div class="slides">


<section id="title-slide" class="slide level2 title-slide-custom center" data-state="titleslide">
<h2>Title Slide</h2>
<div class="logo-container-title">
<p><img src="../qut_logo.jpg" alt="QUT Logo"></p>
</div>
<div class="title-block">
<h1>
Discrete-Time Control Design 3
</h1>
<h2>
Optimal Control
</h2>
</div>
<div class="author-block-title">
<p>Dr Guilherme Froes Silva<br> School of Electrical Engineering &amp; Robotics<br> Queensland University of Technology</p>
</div>
<div class="course-code-title">
<p>EGH445 - Modern Control</p>
</div>
<!-- <div class="website-link-title">
  <a href="../index.html">
    Website
  </a>
</div> -->
<div class="contact-box-title">
<p>Consultation: GP-S1111<br> Email: g.froessilva@qut.edu.au</p>
</div>
</section>
<section>
<section id="overview" class="title-slide slide level1 center" data-state="overview">
<h1>Overview</h1>
<ul>
<li class="fragment">Quick review of (some of) the content so far.</li>
<li class="fragment">When does pole placement work well? <span class="fragment">And when does it fail?</span></li>
<li class="fragment">What is <em>Optimal</em> Control?</li>
<li class="fragment">Why should we do optimal control instead of just pole placement?</li>
<li class="fragment">The Optimal Control Problem.</li>
<li class="fragment">The Linear Quadratic Regulator (LQR).</li>
<li class="fragment">Model Predictive Control (MPC).</li>
</ul>
</section>
<section id="quick-review-of-some-of-the-content-so-far" class="slide level2 smaller scrollable" data-state="review" style="overflow-y:auto;overflow-x:hidden;">
<h2>Quick review of (some of) the content so far</h2>
<div class="fragment">
<p><strong>Continuous-time system:</strong> <span class="math display">
\begin{align*}\dot{x}(t) &amp;= f(x, u), \\ y(t) &amp;= g(x, u) \end{align*}
</span></p>
</div>
<div class="fragment">
<p><strong>Linearised system:</strong> <span class="math display">
\begin{align*}
\delta\dot{x}(t) &amp;= A\delta x(t) + B \delta u(t),  \\
\delta y(t) &amp;= C\delta x(t) + D\delta u(t),
\end{align*}
</span></p>
<p>where <span class="math inline">\delta x = x - \bar x</span>, <span class="math inline">\delta u = u - \bar u</span>, <span class="math inline">\delta y = y - \bar y</span>, and the <span class="math inline">A</span>, <span class="math inline">B</span>, <span class="math inline">C</span>, <span class="math inline">D</span> are the matrices <span class="math display">
\begin{align*}
A = \frac{\partial f}{\partial x} \bigg|_{\bar x, \bar u}
B = \frac{\partial f}{\partial u} \bigg|_{\bar x, \bar u}
C = \frac{\partial g}{\partial x} \bigg|_{\bar x, \bar u}
D = \frac{\partial g}{\partial u} \bigg|_{\bar x, \bar u}
\end{align*}
</span></p>
</div>
<div class="fragment">
<p><strong>Discrete-time system:</strong> <span class="math display">
\begin{align*} x(kT+T) &amp;= Gx(kT) + Hu(kT), \\ y(kT) &amp;= Cx(kT) + Du(kT), \end{align*}
</span></p>
<p>where <span class="math display">
\begin{align*}
G = e^{AT}, \quad H = \left[\int_0^T e^{A\tau} d\tau\right] B \quad \left(\text{or, if $A$ is invertible, } H = A^{-1} (G-I)B\right)
\end{align*}
</span></p>
</div>
<div class="fragment">
<p><strong>State-feedback controller:</strong> <span class="math display">
\begin{align*}
u(k) = -Kx(kT)
\end{align*}
</span></p>
<p>where <span class="math inline">K</span> is the feedback gain matrix that is designed to arbitrarily move the poles of the closed-loop system <span class="math display">
\begin{align*}
x(kT+T) = (G-HK)x(kT)
\end{align*}
</span></p>
<p>for example, by equating the characteristic polynomial of the closed-loop system to a desired polynomial, <span class="math display">
\begin{align*}
\det(zI - (G-HK)) = (z - z_1)(z - z_2) \cdots (z - z_n)
\end{align*}
</span></p>
</div>
<div class="fragment">
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Important</strong></p>
</div>
<div class="callout-content">
<p>The solution exists if the system is controllable, i.e.&nbsp;if the <strong>controllability matrix</strong> <span class="math inline">\;\mathcal{C} = \left[H,\; GH,\; G^2H,\; \ldots,\; G^{n-1}H\right]</span> has full rank (<span class="math inline">\text{rank}(\mathcal{C})=n</span>).</p>
</div>
</div>
</div>
</div>
<div class="fragment">
<p><strong>How do you choose the poles?</strong></p>
<div class="columns">
<div class="column" style="width:50%;">
<ul>
<li class="fragment"><span class="math inline">t_s</span> - settling time</li>
<li class="fragment"><span class="math inline">t_r</span> - rise time</li>
<li class="fragment"><span class="math inline">\%OS</span> - percent overshoot</li>
<li class="fragment"><span class="math inline">\omega_n</span> - natural frequency</li>
<li class="fragment"><span class="math inline">\zeta</span> - damping ratio (or through percent overshoot)</li>
</ul>
</div><div class="column" style="width:50%;">
<ul>
<li class="fragment"><span class="math inline">\zeta = \dfrac{\ln(\%OS/100)}{\sqrt{\pi^2 + \ln^2(\%OS/100)}}</span></li>
<li class="fragment"><span class="math inline">\omega_n = \frac{4}{\zeta t_s}</span></li>
<li class="fragment"><span class="math inline">s_{1,2} = -\zeta \omega_n \pm j \omega_n \sqrt{1-\zeta^2}</span></li>
<li class="fragment"><span class="math inline">z_{1,2} = e^{s_{1,2}T}</span></li>
</ul>
</div></div>
</div>
<div class="fragment">
<p>We also saw the <strong>Internal Model Principle</strong> (e.g.&nbsp;<strong>Integral Action</strong>) to reject disturbances (or follow references) with a known model (e.g.&nbsp;a step input, a ramp input, a sinusoidal input, etc.). Those still relied on the <strong>pole placement</strong> approach.</p>
</div>
</section></section>
<section>
<section id="limitations-of-pole-placement" class="title-slide slide level1 center" data-state="intro">
<h1>Limitations of Pole placement</h1>
<div class="fragment">
<p><em>Works well for:</em></p>
<ul>
<li class="fragment">SISO systems (Single Input Single Output)</li>
<li class="fragment">Low order systems (2nd order or when 2nd order <em>dominant</em>, etc.)</li>
</ul>
</div>
<div class="fragment">
<p><em>Does not work well for:</em></p>
<ul>
<li class="fragment"><strong>Higher-order systems</strong> (4th order, 5th order, etc.)</li>
<li class="fragment"><strong>MIMO systems</strong> (Multiple Input Multiple Output)</li>
<li class="fragment"><em>Stiff</em> systems (e.g.&nbsp;with very different time constants, e.g.&nbsp;1ms and 1s)</li>
<li class="fragment"><strong>Highly nonlinear systems</strong> (i.e.&nbsp;when the linearisation quickly becomes invalid.)</li>
</ul>
</div>
</section>
<section id="higher-order-systems" class="slide level2">
<h2>Higher-Order Systems</h2>
<p><span class="math display">
\begin{align*} x(kT+T) &amp;= Gx(kT) + Hu(kT), \\ y(kT) &amp;= Cx(kT) + Du(kT), \end{align*}
</span></p>
<p>where <span class="math inline">\quad x(kT) \in \mathbb{R}^n, \quad u(kT) \in \mathbb{R}, \quad y(kT) \in \mathbb{R}, \quad n &gt; 3</span></p>
<div class="fragment">
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Important</strong></p>
</div>
<div class="callout-content">
<p>The link between pole locations and desired time-domain response becomes less clear. Arbitrary choices can lead to poor performance or excessive control effort.</p>
<p><em>How do you choose the best pole locations for a 5th, 10th, or higher-order system?</em></p>
</div>
</div>
</div>
</div>
</section>
<section id="mimo-systems" class="slide level2 smaller scrollable">
<h2>MIMO Systems</h2>
<p>Let’s start with an example.</p>
<p>Consider a simple MIMO system with two states and two inputs: <span class="math display">
\begin{align*} x(kT+T) &amp;= \begin{bmatrix} 1 &amp; 0.1 \\ 0 &amp; 0.8 \end{bmatrix} x(kT) + \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix} u(kT)
\end{align*}
</span></p>
<p>We want to place the poles at <span class="math inline">0.4</span> and <span class="math inline">0.6</span>, by using <span class="math inline">u(kT) = -Kx(kT)</span>, where <span class="math inline">K = \begin{bmatrix} k_1 &amp; k_2 \\ k_3 &amp; k_4\end{bmatrix}</span>.</p>
<div class="fragment">
<p>The characteristic polynomial is given by: <span class="math display">
\begin{align*}
&amp;\det(zI - (G-HK)) = \det\left(\begin{bmatrix} z-1+k_1 &amp; k_2-0.1 \\ k_3 &amp; z-0.8+k_4\end{bmatrix}\right) \\
&amp;= z^2 + (k_1 + k_4 - 1.8)z + (0.1k_3 - k_4 - 0.8k_1 + k_1k_4 - k_2k_3 + 0.8)
\end{align*}
</span></p>
</div>
<div class="fragment">
<p>The desired characteristic polynomial is given by: <span class="math display">
\begin{align*}
(z-0.4)(z-0.6) = z^2 - 1z + 0.24
\end{align*}
</span></p>
</div>
<div class="fragment">
<p>When we equate the coefficients, we get: <span class="math display">
\begin{align*}
\begin{cases}
(k_1 + k_4 - 1.8) = -1 \\
0.1k_3 - k_4 - 0.8k_1 + k_1k_4 - k_2k_3 + 0.8 = 0.24
\end{cases}
\end{align*}
</span></p>
</div>
<div class="fragment">
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Important</strong></p>
</div>
<div class="callout-content">
<p>Note that we have <strong>two equations</strong> and <strong>four unknowns</strong>. This means that we have <strong>degrees of freedom</strong> in the design. We can choose two of the four variables arbitrarily, and then solve for the other two.</p>
</div>
</div>
</div>
</div>
<div class="fragment">
<p>This seems like a good idea, but it is not. The problem is that different choices of <span class="math inline">K</span>, even if they lead to the same <strong>eigenvalues</strong>, can lead to different <strong>eigenvectors</strong>. The closed-loop system’s <strong>eigenvectors</strong> directly affect the <strong>response</strong> of the system.</p>
</div>
<div class="fragment">
<p>Let <span class="math inline">k_2 = k_3 = 0</span> and consider the following two cases of gains matrices <span class="math inline">K_1</span> and <span class="math inline">K_2</span>, both of which lead assign the closed-loop eigenvalues to the desired values: <span class="math display">
K_1 = \begin{bmatrix} 0.6 &amp; 0 \\ 0 &amp; 0.2 \end{bmatrix}, \quad K_2 = \begin{bmatrix} 0.4 &amp; 0 \\ 0 &amp; 0.4 \end{bmatrix}
</span></p>
<p>Both of which lead to the same eigenvalues we wanted. But let’s simulate the system with both <span class="math inline">K_1</span> and <span class="math inline">K_2</span>.</p>
<div id="915166e7" class="cell columns column-output-location" data-results="hold" data-execution_count="1">
<div class="column">
<div class="sourceCode cell-code" id="cb1" data-code-line-numbers="1-3|5-8|9-10|11-12|15-17|23-24"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a></a><span class="im">import</span> control <span class="im">as</span> ctrl</span>
<span id="cb1-4"><a></a><span class="co"># Create the system matrices</span></span>
<span id="cb1-5"><a></a>G <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="fl">0.1</span>], [<span class="dv">0</span>, <span class="fl">0.8</span>]])</span>
<span id="cb1-6"><a></a>H <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>]])</span>
<span id="cb1-7"><a></a>C <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>]]) <span class="co"># Outputs are the states</span></span>
<span id="cb1-8"><a></a>D <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>]])</span>
<span id="cb1-9"><a></a>K1 <span class="op">=</span> np.array([[<span class="fl">0.6</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="fl">0.2</span>]]) </span>
<span id="cb1-10"><a></a>K2 <span class="op">=</span> np.array([[<span class="fl">0.4</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="fl">0.4</span>]]) </span>
<span id="cb1-11"><a></a>Gcl1 <span class="op">=</span> G <span class="op">-</span> H <span class="op">@</span> K1 </span>
<span id="cb1-12"><a></a>Gcl2 <span class="op">=</span> G <span class="op">-</span> H <span class="op">@</span> K2</span>
<span id="cb1-13"><a></a></span>
<span id="cb1-14"><a></a>Ts <span class="op">=</span> <span class="fl">0.1</span> <span class="co"># Sampling time (seconds)</span></span>
<span id="cb1-15"><a></a><span class="co"># Create the closed-loop LTI systems</span></span>
<span id="cb1-16"><a></a>sys1 <span class="op">=</span> ctrl.ss(Gcl1, H, C, D, Ts) </span>
<span id="cb1-17"><a></a>sys2 <span class="op">=</span> ctrl.ss(Gcl2, H, C, D, Ts) </span>
<span id="cb1-18"><a></a></span>
<span id="cb1-19"><a></a><span class="co"># Simulate for initial condition x0 = [1, 0]</span></span>
<span id="cb1-20"><a></a>x0 <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb1-21"><a></a>t_end <span class="op">=</span> <span class="fl">1.5</span> </span>
<span id="cb1-22"><a></a>t <span class="op">=</span> np.arange(<span class="dv">0</span>, t_end, Ts) </span>
<span id="cb1-23"><a></a>t1, y1 <span class="op">=</span> ctrl.initial_response(sys1, T<span class="op">=</span>t, X0<span class="op">=</span>x0)</span>
<span id="cb1-24"><a></a>t2, y2 <span class="op">=</span> ctrl.initial_response(sys2, T<span class="op">=</span>t, X0<span class="op">=</span>x0)</span>
<span id="cb1-25"><a></a></span>
<span id="cb1-26"><a></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb1-27"><a></a>plt.plot(t1, y1[<span class="dv">0</span>, :], label<span class="op">=</span><span class="st">'K1 - x1'</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb1-28"><a></a>plt.plot(t1, y1[<span class="dv">1</span>, :], label<span class="op">=</span><span class="st">'K1 - x2'</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb1-29"><a></a>plt.plot(t2, y2[<span class="dv">0</span>, :], label<span class="op">=</span><span class="st">'K2 - x1'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">3</span>) </span>
<span id="cb1-30"><a></a>plt.plot(t2, y2[<span class="dv">1</span>, :], label<span class="op">=</span><span class="st">'K2 - x2'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">3</span>) </span>
<span id="cb1-31"><a></a>plt.title(<span class="st">'Initial Condition Response ($x_0=[1, 0]^T$) with Different K Matrices'</span>, fontsize<span class="op">=</span><span class="dv">16</span>) </span>
<span id="cb1-32"><a></a>plt.xlabel(<span class="st">'Time (steps * dt)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>) </span>
<span id="cb1-33"><a></a>plt.ylabel(<span class="st">'State Values'</span>, fontsize<span class="op">=</span><span class="dv">14</span>) </span>
<span id="cb1-34"><a></a>plt.legend(fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb1-35"><a></a>plt.grid(<span class="va">True</span>) </span>
<span id="cb1-36"><a></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div><div class="column fragment">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture9_files/figure-revealjs/cell-2-output-1.png"></p>
</figure>
</div>
</div>
</div></div>
</div>
</section>
<section id="mimo-systems-1" class="slide level2">
<h2>MIMO Systems</h2>
<p><span class="math display">
\begin{align*} x(kT+T) &amp;= Gx(kT) + Hu(kT), \\ y(kT) &amp;= Cx(kT) + Du(kT), \end{align*}
</span></p>
<p><span class="math inline">x(kT) \in \mathbb{R}^n, \quad u(kT) \in \mathbb{R}^m, \quad y(kT) \in \mathbb{R}^p, \quad n, m, p &gt; 1</span></p>
<div class="fragment">
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Important</strong></p>
</div>
<div class="callout-content">
<p>For MIMO systems, pole placement is significantly more complex. Specifying only the eigenvalues leaves <strong>degrees of freedom</strong> in the <strong>eigenvectors</strong>, which also <strong>affect the response</strong>. The design process becomes <strong>non-unique</strong> and less intuitive.</p>
<p><em>How do you systematically handle interactions between different inputs and outputs?</em></p>
</div>
</div>
</div>
</div>
</section>
<section id="performance-trade-off" class="slide level2">
<h2>Performance trade-off</h2>
<p>Finally, pole placement does not consider the <strong>control effort</strong>, not addressing the trade-off between:</p>
<ul>
<li class="fragment"><p>regulating the state, by making <span class="math inline">x(kT)</span>, or <span class="math inline">\delta x(kT)</span><sup>1</sup>, small</p>
<div class="inline-footnote">
<p><sup>1</sup> For linearised systems, we defined <span class="math inline">\delta x = x - \bar x</span>.</p>
</div></li>
<li class="fragment"><p><em>regulating</em> required control effort <span class="math inline">u(kT)</span>.</p></li>
</ul>
<div class="fragment">
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Important</strong></p>
</div>
<div class="callout-content">
<p>You might achieve <strong>desired poles</strong> but with impractically <strong>large control signals</strong>.</p>
<p>Which, like in the following example, can lead to <strong>instability</strong>.</p>
</div>
</div>
</div>
</div>
</section>
<section id="linear-controller-failure-for-a-nonlinear-system" class="slide level2 smaller scrollable">
<h2>Linear Controller Failure for a Nonlinear System</h2>
<p>Consider a <strong>scalar</strong> system with <strong>cubic nonlinearity</strong>, <span class="math inline">\; \dot{x}(t) = -x(t) + x(t)^3 + u(t)</span>.</p>
<div class="fragment">
<div class="inline-footnote">
<p><span class="math inline">-x</span> represents a stabilizing linear dynamic.</p>
</div>
</div>
<div class="fragment">
<div class="inline-footnote">
<p><span class="math inline">x^3</span> is a destabilizing nonlinearity that becomes significant for larger values of <span class="math inline">|x|</span>.</p>
</div>
</div>
<div class="fragment">
<p>We want to design a controller <span class="math inline">u(kT)</span> to stabilize the system at <span class="math inline">\bar x = 0</span> (requiring <span class="math inline">\bar u = 0</span>).</p>
</div>
<div class="fragment">
<p><strong>1. Linearise</strong> the system around the equilibrium point <span class="math inline">(\bar x=0, \bar u=0)</span>:</p>
</div>
<div class="fragment">
<p><span class="math display">
A = \frac{\partial}{\partial x}(-x + x^3 + u) \Big|_{x=0, u=0} = (-1 + 3x^2)\Big|_{x=0} = -1
</span></p>
</div>
<div class="fragment">
<p><span class="math display">
B = \frac{\partial}{\partial u}(-x + x^3 + u) \Big|_{x=0, u=0} = 1
</span></p>
</div>
<div class="fragment">
<p>The linearised continuous-time system is <span class="math inline">\;\boxed{\delta\dot{x}(t) = -\delta x(t) + \delta u(t)}</span>.</p>
</div>
<div class="fragment">
<p><strong>2. Discretise</strong> the system with a sampling time <span class="math inline">T=0.1</span>s: <span class="math display">
\begin{align*} x(kT+T) &amp;= Gx(kT) + Hu(kT), \quad y(kT) = x(kT) \end{align*}
</span></p>
<p>where <span class="math inline">G = e^{-AT} = 0.905</span>, and <span class="math inline">H = A^{-1}(G-I)B = 0.095</span>.</p>
<p>The discrete-time (linearised) system is <span class="math inline">\boxed{x(kT+T) = 0.905x(kT) + 0.095u(kT)}</span>.</p>
</div>
<div class="fragment">
<p><strong>3. Design <span class="math inline">u(kT) = -K x(kT)</span></strong> to place the closed-loop pole of this <em>linearised</em> system at <span class="math inline">p = 0.5</span>.</p>
<p><em>3.1 Design through pole placement.</em> The closed-loop is <span class="math inline">x(kT+T) = (G - H K) x(kT)</span>.</p>
<p>We want the closed-loop pole to be equal to <span class="math inline">p=0.5</span>:</p>
</div>
<div class="fragment">
<div class="inline-footnote">
<p>Try to do this through equating the characteristic polynomials: <span class="math inline">\det(zI - (G-HK)) = (z-p)</span>.</p>
</div>
</div>
<div class="fragment">
<p><span class="math display">
\begin{align*} 0.905 - 0.095 K &amp;= 0.5 \\ 0.095 K &amp;= 0.905 - 0.5 = 0.405 \\ K &amp;= \frac{0.405}{0.095} = 4.263 \end{align*}
</span></p>
<p>So, the linear controller designed for the linearized system is <span class="math inline">\boxed{u(kT) = -4.263 x(kT)}</span>.</p>
</div>
<div class="fragment">
<p><strong>4. Test the controller on the original nonlinear system.</strong></p>
<p>Simulate the continuous nonlinear dynamics, but apply the control input <span class="math inline">u(kT) = -K x(kT)</span> constant over the period <span class="math inline">[kT, kT + T)</span> (Zero-Order Hold).</p>
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Important</strong></p>
</div>
<div class="callout-content">
<p>Note that the controller was derived for the <strong>linearised</strong> system, which <strong>ignores</strong> the <span class="math inline">x^3</span> term. The linear model is only accurate for small <span class="math inline">x</span> (close to the equilibrium <span class="math inline">x=0</span>). When <span class="math inline">|x|</span> becomes large, the <span class="math inline">x^3</span> term can dominate, and the linear controller may fail.</p>
</div>
</div>
</div>
<div id="c0e1a146" class="cell columns column-output-location" data-results="hold" data-execution_count="2">
<div class="column">
<div class="sourceCode cell-code" id="cb2" data-code-line-numbers="1-3|8-11|13-18|20-23|29-37|42-63|104-120"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a></a><span class="im">from</span> scipy.integrate <span class="im">import</span> solve_ivp</span>
<span id="cb2-3"><a></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-4"><a></a></span>
<span id="cb2-5"><a></a><span class="co"># Set default font size for plots</span></span>
<span id="cb2-6"><a></a>plt.rcParams[<span class="st">'font.size'</span>] <span class="op">=</span> <span class="dv">14</span> </span>
<span id="cb2-7"><a></a></span>
<span id="cb2-8"><a></a><span class="co"># 1. Nonlinear System Dynamics</span></span>
<span id="cb2-9"><a></a><span class="kw">def</span> nonlinear_system(x, u):</span>
<span id="cb2-10"><a></a>    <span class="co"># Scalar system dynamics: dx/dt = -x + x^3 + u</span></span>
<span id="cb2-11"><a></a>    <span class="cf">return</span> <span class="op">-</span>x <span class="op">+</span> x<span class="op">**</span><span class="dv">3</span> <span class="op">+</span> u</span>
<span id="cb2-12"><a></a></span>
<span id="cb2-13"><a></a><span class="co"># 2. Linear Controller Parameters (derived above)</span></span>
<span id="cb2-14"><a></a>Ad <span class="op">=</span> <span class="fl">0.905</span></span>
<span id="cb2-15"><a></a>Bd <span class="op">=</span> <span class="fl">0.095</span></span>
<span id="cb2-16"><a></a>K <span class="op">=</span> <span class="fl">4.263</span></span>
<span id="cb2-17"><a></a>Ts <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb2-18"><a></a>x_eq <span class="op">=</span> <span class="fl">0.0</span> <span class="co"># Equilibrium state</span></span>
<span id="cb2-19"><a></a></span>
<span id="cb2-20"><a></a><span class="co"># 3. Simulation Setup</span></span>
<span id="cb2-21"><a></a>t_start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-22"><a></a>t_end <span class="op">=</span> <span class="fl">1.0</span> <span class="co"># Shorter simulation time might be enough</span></span>
<span id="cb2-23"><a></a>n_steps <span class="op">=</span> <span class="bu">int</span>(t_end <span class="op">/</span> Ts)</span>
<span id="cb2-24"><a></a></span>
<span id="cb2-25"><a></a><span class="co"># Initial Conditions to compare</span></span>
<span id="cb2-26"><a></a>x0_small <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-27"><a></a>x0_large <span class="op">=</span> <span class="fl">2.4</span></span>
<span id="cb2-28"><a></a></span>
<span id="cb2-29"><a></a><span class="co"># Function to run the simulation for a given x0</span></span>
<span id="cb2-30"><a></a><span class="kw">def</span> run_simulation_smooth(x0_val, points_per_interval<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb2-31"><a></a>    <span class="co"># Store results for smooth plotting</span></span>
<span id="cb2-32"><a></a>    t_history_smooth <span class="op">=</span> [t_start]</span>
<span id="cb2-33"><a></a>    x_history_smooth <span class="op">=</span> [x0_val]</span>
<span id="cb2-34"><a></a>    <span class="co"># Store results at discrete intervals for markers and control calc</span></span>
<span id="cb2-35"><a></a>    t_history_discrete <span class="op">=</span> [t_start]</span>
<span id="cb2-36"><a></a>    x_history_discrete <span class="op">=</span> [x0_val]</span>
<span id="cb2-37"><a></a>    u_history <span class="op">=</span> [] <span class="co"># Control applied over the interval starting at t_history_discrete</span></span>
<span id="cb2-38"><a></a></span>
<span id="cb2-39"><a></a>    current_t <span class="op">=</span> t_start</span>
<span id="cb2-40"><a></a>    current_x_start_of_interval <span class="op">=</span> np.array([x0_val]) <span class="co"># State at beginning of interval</span></span>
<span id="cb2-41"><a></a></span>
<span id="cb2-42"><a></a>    <span class="co"># print(f"\nRunning smooth simulation for x(0) = {x0_val}...")</span></span>
<span id="cb2-43"><a></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb2-44"><a></a>        <span class="co"># Calculate discrete control based on state at START of interval</span></span>
<span id="cb2-45"><a></a>        x_deviation <span class="op">=</span> current_x_start_of_interval[<span class="dv">0</span>] <span class="op">-</span> x_eq</span>
<span id="cb2-46"><a></a>        u_k <span class="op">=</span> <span class="op">-</span>K <span class="op">*</span> x_deviation</span>
<span id="cb2-47"><a></a>        <span class="co"># Optional: Limit control effort</span></span>
<span id="cb2-48"><a></a>        <span class="co"># u_k = np.clip(u_k, -u_max, u_max)</span></span>
<span id="cb2-49"><a></a>        u_history.append(u_k)</span>
<span id="cb2-50"><a></a></span>
<span id="cb2-51"><a></a>        <span class="co"># Define ODE function for this interval (constant u_k)</span></span>
<span id="cb2-52"><a></a>        <span class="kw">def</span> ode_interval(t, y): <span class="co"># y is a 1-element array</span></span>
<span id="cb2-53"><a></a>            <span class="cf">return</span> np.array([nonlinear_system(y[<span class="dv">0</span>], u_k)])</span>
<span id="cb2-54"><a></a></span>
<span id="cb2-55"><a></a>        <span class="co"># Simulate one interval Ts, evaluating at multiple points</span></span>
<span id="cb2-56"><a></a>        t_eval_interval <span class="op">=</span> np.linspace(current_t, current_t <span class="op">+</span> Ts, points_per_interval, endpoint<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-57"><a></a>        sol_interval <span class="op">=</span> solve_ivp(</span>
<span id="cb2-58"><a></a>            ode_interval,</span>
<span id="cb2-59"><a></a>            (current_t, current_t <span class="op">+</span> Ts), <span class="co"># t_span for the interval</span></span>
<span id="cb2-60"><a></a>            current_x_start_of_interval, <span class="co"># Initial state for interval</span></span>
<span id="cb2-61"><a></a>            method<span class="op">=</span><span class="st">'RK45'</span>,</span>
<span id="cb2-62"><a></a>            t_eval<span class="op">=</span>t_eval_interval <span class="co"># Evaluate at these points</span></span>
<span id="cb2-63"><a></a>        )</span>
<span id="cb2-64"><a></a></span>
<span id="cb2-65"><a></a>        <span class="cf">if</span> sol_interval.status <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb2-66"><a></a>            <span class="bu">print</span>(<span class="ss">f"Simulation failed at step </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> (t=</span><span class="sc">{</span>current_t<span class="sc">:.2f}</span><span class="ss">) for x(0)=</span><span class="sc">{</span>x0_val<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-67"><a></a>            <span class="co"># Pad history if needed</span></span>
<span id="cb2-68"><a></a>            <span class="co"># ... (padding logic can be added if needed) ...</span></span>
<span id="cb2-69"><a></a>            <span class="cf">break</span></span>
<span id="cb2-70"><a></a></span>
<span id="cb2-71"><a></a>        <span class="co"># Update state for next interval START</span></span>
<span id="cb2-72"><a></a>        current_x_start_of_interval <span class="op">=</span> sol_interval.y[:, <span class="op">-</span><span class="dv">1</span>] <span class="co"># State at the end</span></span>
<span id="cb2-73"><a></a>        current_t <span class="op">+=</span> Ts</span>
<span id="cb2-74"><a></a></span>
<span id="cb2-75"><a></a>        <span class="co"># Store history</span></span>
<span id="cb2-76"><a></a>        <span class="co"># Append points *after* the first one to avoid duplication</span></span>
<span id="cb2-77"><a></a>        t_history_smooth.extend(sol_interval.t[<span class="dv">1</span>:])</span>
<span id="cb2-78"><a></a>        x_history_smooth.extend(sol_interval.y[<span class="dv">0</span>, <span class="dv">1</span>:])</span>
<span id="cb2-79"><a></a>        <span class="co"># Store discrete points</span></span>
<span id="cb2-80"><a></a>        t_history_discrete.append(current_t)</span>
<span id="cb2-81"><a></a>        x_history_discrete.append(current_x_start_of_interval[<span class="dv">0</span>])</span>
<span id="cb2-82"><a></a></span>
<span id="cb2-83"><a></a></span>
<span id="cb2-84"><a></a>        <span class="co"># Stop if state diverges excessively</span></span>
<span id="cb2-85"><a></a>        <span class="cf">if</span> <span class="bu">abs</span>(current_x_start_of_interval[<span class="dv">0</span>]) <span class="op">&gt;</span> <span class="dv">10</span>:</span>
<span id="cb2-86"><a></a>            <span class="bu">print</span>(<span class="ss">f"State diverging at step </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> (t=</span><span class="sc">{</span>current_t<span class="sc">:.2f}</span><span class="ss">) for x(0)=</span><span class="sc">{</span>x0_val<span class="sc">}</span><span class="ss">. Stopping."</span>)</span>
<span id="cb2-87"><a></a>            <span class="cf">break</span></span>
<span id="cb2-88"><a></a></span>
<span id="cb2-89"><a></a>    <span class="cf">return</span> (np.array(t_history_smooth), np.array(x_history_smooth), <span class="co"># Smooth results</span></span>
<span id="cb2-90"><a></a>            np.array(t_history_discrete), np.array(x_history_discrete), <span class="co"># Discrete results</span></span>
<span id="cb2-91"><a></a>            np.array(u_history)) <span class="co"># Control history</span></span>
<span id="cb2-92"><a></a></span>
<span id="cb2-93"><a></a><span class="co"># --- Run both simulations ---</span></span>
<span id="cb2-94"><a></a>(t_small_smooth, x_small_smooth,</span>
<span id="cb2-95"><a></a> t_small_discrete, x_small_discrete, u_small) <span class="op">=</span> run_simulation_smooth(x0_small)</span>
<span id="cb2-96"><a></a></span>
<span id="cb2-97"><a></a>(t_large_smooth, x_large_smooth,</span>
<span id="cb2-98"><a></a> t_large_discrete, x_large_discrete, u_large) <span class="op">=</span> run_simulation_smooth(x0_large)</span>
<span id="cb2-99"><a></a></span>
<span id="cb2-100"><a></a></span>
<span id="cb2-101"><a></a><span class="co"># --- MODIFIED Plotting Section ---</span></span>
<span id="cb2-102"><a></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb2-103"><a></a></span>
<span id="cb2-104"><a></a><span class="co"># --- Plot states (Top Plot) ---</span></span>
<span id="cb2-105"><a></a>plt.subplot(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb2-106"><a></a><span class="co"># Plot smooth trajectories</span></span>
<span id="cb2-107"><a></a>plt.plot(t_small_smooth, x_small_smooth,</span>
<span id="cb2-108"><a></a>         label<span class="op">=</span><span class="ss">f'State x(t) (x0=</span><span class="sc">{</span>x0_small<span class="sc">}</span><span class="ss">)'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb2-109"><a></a>plt.plot(t_large_smooth, x_large_smooth,</span>
<span id="cb2-110"><a></a>         label<span class="op">=</span><span class="ss">f'State x(t) (x0=</span><span class="sc">{</span>x0_large<span class="sc">}</span><span class="ss">)'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb2-111"><a></a></span>
<span id="cb2-112"><a></a>plt.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>, linestyle<span class="op">=</span><span class="st">':'</span>)</span>
<span id="cb2-113"><a></a>plt.ylabel(<span class="st">'State x'</span>)</span>
<span id="cb2-114"><a></a>plt.title(<span class="st">'Scalar Nonlinear System with Linear Controller (Pole @ 0.5)'</span>)</span>
<span id="cb2-115"><a></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb2-116"><a></a>plt.legend()</span>
<span id="cb2-117"><a></a><span class="co"># Adjust ylim automatically or set manually if needed</span></span>
<span id="cb2-118"><a></a>ylim_min <span class="op">=</span> <span class="bu">min</span>(np.nanmin(x_small_smooth), np.nanmin(x_large_smooth), <span class="op">-</span><span class="dv">1</span>) <span class="op">-</span> <span class="fl">0.5</span></span>
<span id="cb2-119"><a></a>ylim_max <span class="op">=</span> <span class="bu">max</span>(np.nanmax(x_small_smooth), np.nanmax(x_large_smooth), <span class="dv">1</span>) <span class="op">+</span> <span class="fl">0.5</span></span>
<span id="cb2-120"><a></a>plt.ylim(ylim_min, ylim_max)</span>
<span id="cb2-121"><a></a></span>
<span id="cb2-122"><a></a><span class="co"># --- Plot control inputs (Bottom Plot - using stairs) ---</span></span>
<span id="cb2-123"><a></a>plt.subplot(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb2-124"><a></a><span class="co"># Ensure simulation ran successfully and generated history</span></span>
<span id="cb2-125"><a></a>final_idx_small <span class="op">=</span> <span class="bu">len</span>(u_small)</span>
<span id="cb2-126"><a></a><span class="cf">if</span> final_idx_small <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-127"><a></a>    plt.stairs(u_small, t_small_discrete, label<span class="op">=</span><span class="ss">f'Control u[k] (x0=</span><span class="sc">{</span>x0_small<span class="sc">}</span><span class="ss">)'</span>,</span>
<span id="cb2-128"><a></a>               baseline<span class="op">=</span><span class="va">None</span>, linewidth<span class="op">=</span><span class="dv">2</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb2-129"><a></a></span>
<span id="cb2-130"><a></a>final_idx_large <span class="op">=</span> <span class="bu">len</span>(u_large)</span>
<span id="cb2-131"><a></a><span class="cf">if</span> final_idx_large <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-132"><a></a>    plt.stairs(u_large[:final_idx_large<span class="op">-</span><span class="dv">1</span>], t_large_discrete, label<span class="op">=</span><span class="ss">f'Control u[k] (x0=</span><span class="sc">{</span>x0_large<span class="sc">}</span><span class="ss">)'</span>,</span>
<span id="cb2-133"><a></a>               baseline<span class="op">=</span><span class="va">None</span>, linewidth<span class="op">=</span><span class="dv">2</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb2-134"><a></a></span>
<span id="cb2-135"><a></a></span>
<span id="cb2-136"><a></a>plt.ylabel(<span class="st">'Control Input u'</span>)</span>
<span id="cb2-137"><a></a>plt.xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb2-138"><a></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb2-139"><a></a>plt.legend()</span>
<span id="cb2-140"><a></a></span>
<span id="cb2-141"><a></a>plt.tight_layout()</span>
<span id="cb2-142"><a></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div><div class="column fragment">
<div class="cell-output cell-output-stdout">
<pre><code>Simulation failed at step 2 (t=0.20) for x(0)=2.4</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture9_files/figure-revealjs/cell-3-output-2.png"></p>
</figure>
</div>
</div>
</div></div>
</div>
</section></section>
<section>
<section id="optimal-control" class="title-slide slide level1 center" data-state="optimal-control">
<h1>Optimal Control</h1>
<p><em>What is optimal?</em></p>
<div class="fragment">
<p><strong>Optimal</strong> means <strong>best</strong>. But best in terms of what?</p>
<div class="smaller">
<ul>
<li class="fragment"><strong>Best</strong> in terms of <em>performance</em>?</li>
<li class="fragment"><strong>Best</strong> in terms of <em>low control effort</em>?</li>
<li class="fragment"><strong>Best</strong> in terms of a <strong><em><span class="fragment highlight-red">(generalised)</span> cost</em></strong>?</li>
</ul>
</div>
</div>
<div class="fragment">
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Key Idea:</strong></p>
</div>
<div class="callout-content">
<p>Instead of choosing pole locations, you define what constitutes good <strong>performance</strong> via a <strong>cost function</strong> <span class="math inline">J</span>.</p>
</div>
</div>
</div>
</div>
</section>
<section id="the-discrete-time-optimal-control-problem" class="slide level2 smaller">
<h2>The Discrete-Time Optimal Control Problem</h2>
<p>Consider the <strong>System Dynamics</strong><sup>1</sup>, <span class="math inline">\; x(kT+T) = Gx(kT) + Hu(kT), \quad x(0) = x_0</span>.</p>
<div class="inline-footnote">
<p><sup>1</sup>The general concept extends to nonlinear systems, but through methods that are beyond the scope of this course.</p>
</div>
<div class="fragment">
<p>We want to find <span class="math inline">u(kT) = -Kx(kT)</span> that minimizes the <strong>Cost Function / Performance Index</strong><sup>2</sup>:</p>
<p><span class="math display">
J = \sum_{k=0}^{\infty} \left( x(kT)^T Q x(kT) + u(kT)^T R u(kT) \right), \quad Q\succeq 0, \quad R\succ 0
</span></p>
<div class="inline-footnote">
<p><sup>2</sup> This is an <em>infinite horizon</em> cost function, where the <strong>state penalty matrix <span class="math inline">Q</span></strong> and the <strong>control penalty matrix</strong> <span class="math inline">R</span> define the cost.</p>
</div>

</div>
<div class="fragment">
<p>The solution to this problem is the <span class="fragment highlight-current-blue">Linear</span> <span class="fragment highlight-current-blue">Quadratic</span> <span class="fragment highlight-current-blue">Regulator</span> <span class="fragment fade-left">(LQR).</span></p>
<div class="fragment">
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Additional Reading</strong></p>
</div>
<div class="callout-content">
<p>For more information about the general optimal control problem, see the additional readings on Canvas.</p>
</div>
</div>
</div>
</div>
</div>
<aside><div>
<p><span class="fragment"><span class="math inline">A\succeq 0</span> means that <span class="math inline">A</span> is positive semi-definite, i.e.&nbsp;<span class="math inline">x^T A x \geq 0</span> for all <span class="math inline">x \in \mathbb{R}^n</span>.</span></p>
<p><span class="fragment"><span class="math inline">A\succ 0</span> means that <span class="math inline">A</span> is positive definite, i.e.&nbsp;<span class="math inline">x^T A x &gt; 0</span> for all <span class="math inline">x \in \mathbb{R}^n</span> and <span class="math inline">x \neq 0</span>.</span></p>
</div></aside></section>
<section id="the-discrete-linear-quadratic-regulator-dlqr" class="slide level2 smaller scrollable">
<h2>The Discrete Linear Quadratic Regulator (DLQR)</h2>
<p>The gain <span class="math inline">K</span> that minimizes the cost function<sup>1</sup>, subject to the system dynamics<sup>2</sup> is given by:</p>
<p><span class="math display">
K = (R + H^\intercal P H)^{-1} H^\intercal P G,
</span></p>
<div class="fragment">
<p>which depends on the <em>unique, symmetric, positive semi-definite</em> solution <span class="math inline">S</span> of the <strong>Discrete Algebraic Riccati Equation (DARE)</strong>: <span class="math display">
P = G^\intercal PG - (G^\intercal PH)(R+H^\intercal PH)^{-1}(H^\intercal PG) + Q,
</span></p>
<div class="inline-footnote">
<p>Remember that <span class="math inline">P</span> <strong>must</strong> be <em>unique, symmetric, positive semi-definite</em>, that is <span class="math inline">P=P^\intercal\succeq 0</span>.</p>
</div>
</div>
<div class="fragment">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Note</strong></p>
</div>
<div class="callout-content">
<p>The full derivation of the optimal control gain <span class="math inline">K</span> formula is beyond the scope of the course. If you’re curious, start by investigating the <strong>Bellman’s Principle of Optimality (Dynamic Programming)</strong>.</p>
</div>
</div>
</div>
</div>
<aside><ol class="aside-footnotes"><li id="fn1"><p><span class="math inline">J = \sum_{k=0}^{\infty} \left( x(kT)^T Q x(kT) + u(kT)^T R u(kT) \right), \quad Q\succeq 0, \quad R\succ 0</span></p></li><li id="fn2"><p><span class="math inline">x(kT+T) = Gx(kT) + Hu(kT), \quad x(0) = x_0</span></p></li></ol></aside></section>
<section id="design-of-dlqr-controllers" class="slide level2">
<h2>Design of DLQR Controllers</h2>
<p>The design of DLQR controllers is based on the following steps:</p>
<div class="list-style-numbered">
<ul>
<li class="fragment"><p>Check controllability of <span class="math inline">x(KT+T) = Gx(kT) + Hu(kT)</span>.</p></li>
<li class="fragment"><p>Select the cost matrices <span class="math inline">Q\succeq 0</span> and <span class="math inline">R\succ 0</span>.</p>
<div class="inline-footnote">
<p><span class="math inline">J = \sum_{k=0}^{\infty} \left( x(kT)^T Q x(kT) + u(kT)^T R u(kT) \right)</span></p>
</div></li>
<li class="fragment"><p>Solve the DARE to find the <strong>positive semi-definite symmetric</strong> <span class="math inline">P</span>.</p></li>
<li class="fragment"><p>Compute the gain matrix <span class="math inline">K = (R + H^\intercal P H)^{-1} H^\intercal P G</span>.</p></li>
<li class="fragment"><p>Implement the controller <span class="math inline">u(kT) = -Kx(kT)</span>.</p></li>
<li class="fragment"><p>Test the controller performance and adjust <span class="math inline">Q</span> and <span class="math inline">R</span> as necessary.</p></li>
</ul>
</div>
</section>
<section id="existence-and-stability-of-the-solution" class="slide level2">
<h2>Existence and Stability of the Solution</h2>
<p>We need to check if the solution to the DARE exists and is stable.</p>
<div class="fragment">
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Questions</strong></p>
</div>
<div class="callout-content">
<ul>
<li class="fragment">Does a <em>unique</em> solution to the DARE always exist?</li>
<li class="fragment">Does the resulting controller guarantee stability?</li>
</ul>
</div>
</div>
</div>
</div>
<div class="fragment">
<p>Turns out that we need the following conditions.</p>
<p><strong>Conditions for Stabilizing DLQR Solution:</strong></p>
<ul>
<li class="fragment"><strong>Controllability</strong>: Can the controller move all unstable poles of the system?</li>
<li class="fragment"><strong>Observability</strong>: Can all unstable models be observed <strong>by the cost function</strong>?</li>
</ul>
</div>
</section>
<section id="the-dlqr-stability-theorem" class="slide level2 scrollable">
<h2>The DLQR Stability Theorem</h2>
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Theorem: DLQR Stability Theorem</strong></p>
</div>
<div class="callout-content">
<p>Assume <span class="math inline">R \succ 0</span> and <span class="math inline">Q \succeq 0</span>. Let <span class="math inline">Q=V^TV</span> (where <span class="math inline">V</span> might not be unique).</p>
<p>If the following conditions hold:</p>
<div class="list-style-numbered">
<ul>
<li class="fragment"><p>The pair <span class="math inline">(G,H)</span> is controllable.</p></li>
<li class="fragment"><p>The pair <span class="math inline">(G,V)</span> is observable<sup>1</sup>.</p>
<div class="inline-footnote">
<p><sup>1</sup>Note that this is not the same as the observability of the system, as what’s important is observability of states <strong>by the cost function</strong>.</p>
</div></li>
</ul>
</div>
<p><span class="fragment">Then:</span></p>
<ol type="1">
<li class="fragment">A unique solution <span class="math inline">P=P^\intercal \succeq 0</span> to the DARE exists.</li>
<li class="fragment">The resulting controller closed-loop system is stable.</li>
</ol>
</div>
</div>
</div>
</section>
<section id="simple-example-of-dlqr-design" class="slide level2 smaller scrollable">
<h2>Simple Example of DLQR Design</h2>
<p>Let’s consider a simple example of a DLQR design and solve it “by hand”. Consider again the scalar system with cubic nonlinearity and its discrete linearised version,</p>
<p><span class="math display">
\dot{x}(t) = -x(t) + x(t)^3 + u(t) \quad \rightarrow \quad x(kT+T) = 0.905x(kT) + 0.095u(kT)
</span></p>
<ul>
<li class="fragment"><strong>Controllability</strong>: <span class="math inline">\mathcal{C} = [H,\; GH] = [0.095,\; 0.086475]</span> has full rank (<span class="math inline">\text{rank}(\mathcal{C})=1</span>).</li>
<li class="fragment"><strong>Cost Matrices</strong>: Select <span class="math inline">Q = 10.0</span> and <span class="math inline">R = 0.1</span>.</li>
<li class="fragment"><strong>Observability</strong>: <span class="math inline">\mathcal{O} = [V,\; VG]^\intercal</span>, where <span class="math inline">V = \sqrt{Q}</span>. Then <span class="math inline">\mathcal{O} = [3.162,\; 2.857]^\intercal</span>, which has full rank.</li>
<li class="fragment"><strong>Solution <span class="math inline">P=P^\intercal\succeq 0</span> of the DARE</strong>: <span class="math inline">P - G^\intercal P G + (G^\intercal P H)(R + H^\intercal P H)^{-1}(H^\intercal P G) = Q</span> <span class="math display">
\begin{align*}
P - G^2 P + \frac{(G H P)^2}{R + H^2 P} &amp;= Q \\
(P - G^2 P)(R + H^2 P) + G^2 H^2 P^2 &amp;= Q (R + H^2 P) \\
P R + H^2 P^2 - G^2 P R - Q R - Q H^2 P &amp;= 0 \\
(H^2) P^2 + (R - G^2 R - Q H^2) P + (- Q R) &amp;= 0 \\
0.009 P^2 -0.0722 P - 1 &amp;= 0 \\
P = 15.2571 \text{ or } P = -7.2624
\end{align*}
</span></li>
<li class="fragment"><strong>Pick the <em>positive semi-definite</em> solution</strong>: <span class="math inline">P = 15.2571</span>.</li>
<li class="fragment"><strong>Compute the gain</strong> <span class="math inline">K = (R + H^\intercal P H)^{-1} H^\intercal P G = 5.519</span>.</li>
</ul>
<div id="f7a88ba3" class="cell columns column-output-location" data-results="hold" data-execution_count="3">
<div class="column">
<div class="sourceCode cell-code" id="cb4" data-code-line-numbers="3|30-32|34-49|"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a></a><span class="im">from</span> scipy.integrate <span class="im">import</span> solve_ivp</span>
<span id="cb4-3"><a></a><span class="im">from</span> scipy.linalg <span class="im">import</span> solve_discrete_are <span class="co"># Import DARE solver</span></span>
<span id="cb4-4"><a></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-5"><a></a></span>
<span id="cb4-6"><a></a><span class="co"># Set default font size for plots</span></span>
<span id="cb4-7"><a></a>plt.rcParams[<span class="st">'font.size'</span>] <span class="op">=</span> <span class="dv">14</span> </span>
<span id="cb4-8"><a></a></span>
<span id="cb4-9"><a></a><span class="co"># 1. Nonlinear System Dynamics</span></span>
<span id="cb4-10"><a></a><span class="kw">def</span> nonlinear_system(x, u):</span>
<span id="cb4-11"><a></a>    <span class="co"># Scalar system dynamics: dx/dt = -x + x^3 + u</span></span>
<span id="cb4-12"><a></a>    <span class="cf">return</span> <span class="op">-</span>x <span class="op">+</span> x<span class="op">**</span><span class="dv">3</span> <span class="op">+</span> u</span>
<span id="cb4-13"><a></a></span>
<span id="cb4-14"><a></a><span class="co"># 2. Linear Controller Parameters (derived above)</span></span>
<span id="cb4-15"><a></a>Ad <span class="op">=</span> <span class="fl">0.905</span></span>
<span id="cb4-16"><a></a>Bd <span class="op">=</span> <span class="fl">0.095</span></span>
<span id="cb4-17"><a></a>K <span class="op">=</span> <span class="fl">4.263</span></span>
<span id="cb4-18"><a></a>Ts <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb4-19"><a></a>x_eq <span class="op">=</span> <span class="fl">0.0</span> <span class="co"># Equilibrium state</span></span>
<span id="cb4-20"><a></a></span>
<span id="cb4-21"><a></a><span class="co"># 3. Simulation Setup</span></span>
<span id="cb4-22"><a></a>t_start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-23"><a></a>t_end <span class="op">=</span> <span class="fl">1.0</span> <span class="co"># Shorter simulation time might be enough</span></span>
<span id="cb4-24"><a></a>n_steps <span class="op">=</span> <span class="bu">int</span>(t_end <span class="op">/</span> Ts)</span>
<span id="cb4-25"><a></a></span>
<span id="cb4-26"><a></a><span class="co"># Initial Conditions to compare</span></span>
<span id="cb4-27"><a></a>x0_small <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb4-28"><a></a>x0_large <span class="op">=</span> <span class="fl">2.4</span></span>
<span id="cb4-29"><a></a></span>
<span id="cb4-30"><a></a><span class="co"># --- DLQR Controller Design ---</span></span>
<span id="cb4-31"><a></a>Qd <span class="op">=</span> <span class="fl">10.0</span>  <span class="co"># State weight</span></span>
<span id="cb4-32"><a></a>Rd <span class="op">=</span> <span class="fl">0.1</span>  <span class="co"># Control weight</span></span>
<span id="cb4-33"><a></a></span>
<span id="cb4-34"><a></a><span class="co"># Solve Discrete Algebraic Riccati Equation (DARE)</span></span>
<span id="cb4-35"><a></a><span class="co"># Need to pass arguments as 2D arrays for the solver</span></span>
<span id="cb4-36"><a></a>A_dare <span class="op">=</span> np.array([[Ad]])</span>
<span id="cb4-37"><a></a>B_dare <span class="op">=</span> np.array([[Bd]])</span>
<span id="cb4-38"><a></a>Q_dare <span class="op">=</span> np.array([[Qd]])</span>
<span id="cb4-39"><a></a>R_dare <span class="op">=</span> np.array([[Rd]])</span>
<span id="cb4-40"><a></a></span>
<span id="cb4-41"><a></a>S <span class="op">=</span> solve_discrete_are(A_dare, B_dare, Q_dare, R_dare)</span>
<span id="cb4-42"><a></a>S_scalar <span class="op">=</span> S[<span class="dv">0</span>, <span class="dv">0</span>] <span class="co"># Extract scalar value</span></span>
<span id="cb4-43"><a></a></span>
<span id="cb4-44"><a></a><span class="co"># Calculate DLQR gain Kd</span></span>
<span id="cb4-45"><a></a><span class="co"># Kd = (R + B'SB)^-1 B'SA</span></span>
<span id="cb4-46"><a></a>Kd_term1 <span class="op">=</span> R_dare <span class="op">+</span> B_dare.T <span class="op">@</span> S <span class="op">@</span> B_dare</span>
<span id="cb4-47"><a></a>Kd_term2 <span class="op">=</span> B_dare.T <span class="op">@</span> S <span class="op">@</span> A_dare</span>
<span id="cb4-48"><a></a>Kd <span class="op">=</span> np.linalg.inv(Kd_term1) <span class="op">@</span> Kd_term2</span>
<span id="cb4-49"><a></a>K_lqr <span class="op">=</span> Kd[<span class="dv">0</span>, <span class="dv">0</span>] <span class="co"># Extract scalar gain</span></span>
<span id="cb4-50"><a></a></span>
<span id="cb4-51"><a></a><span class="co"># Check closed-loop stability for the linear system</span></span>
<span id="cb4-52"><a></a>Acl_lqr <span class="op">=</span> Ad <span class="op">-</span> Bd <span class="op">*</span> K_lqr</span>
<span id="cb4-53"><a></a><span class="bu">print</span>(<span class="ss">f"DARE Solution S = </span><span class="sc">{</span>S_scalar<span class="sc">:.3f}</span><span class="ss"> (for Q=</span><span class="sc">{</span>Qd<span class="sc">}</span><span class="ss">, R=</span><span class="sc">{</span>Rd<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb4-54"><a></a><span class="bu">print</span>(<span class="ss">f"DLQR Gain K = </span><span class="sc">{</span>K_lqr<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb4-55"><a></a><span class="cf">if</span> <span class="bu">abs</span>(Acl_lqr) <span class="op">&lt;</span> <span class="dv">1</span>:</span>
<span id="cb4-56"><a></a>    <span class="bu">print</span>(<span class="ss">f"Linear Closed-Loop Pole = </span><span class="sc">{</span>Acl_lqr<span class="sc">:.3f}</span><span class="ss">. (STABLE)"</span>)</span>
<span id="cb4-57"><a></a><span class="cf">else</span>:</span>
<span id="cb4-58"><a></a>    <span class="bu">print</span>(<span class="ss">f"Linear Closed-Loop Pole = </span><span class="sc">{</span>Acl_lqr<span class="sc">:.3f}</span><span class="ss">. (UNSTABLE)"</span>)</span>
<span id="cb4-59"><a></a><span class="co"># --- End DLQR Design ---</span></span>
<span id="cb4-60"><a></a></span>
<span id="cb4-61"><a></a><span class="co"># Function to run the simulation (same as before, just uses K_lqr)</span></span>
<span id="cb4-62"><a></a><span class="kw">def</span> run_simulation(x0_val, K_gain):</span>
<span id="cb4-63"><a></a>    t_history <span class="op">=</span> [t_start]</span>
<span id="cb4-64"><a></a>    x_history <span class="op">=</span> [x0_val]</span>
<span id="cb4-65"><a></a>    u_history <span class="op">=</span> []</span>
<span id="cb4-66"><a></a>    current_t <span class="op">=</span> t_start</span>
<span id="cb4-67"><a></a>    current_x <span class="op">=</span> np.array([x0_val]) <span class="co"># State needs to be array</span></span>
<span id="cb4-68"><a></a></span>
<span id="cb4-69"><a></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb4-70"><a></a>        x_deviation <span class="op">=</span> current_x[<span class="dv">0</span>] <span class="op">-</span> x_eq</span>
<span id="cb4-71"><a></a>        u_k <span class="op">=</span> <span class="op">-</span>K_gain <span class="op">*</span> x_deviation</span>
<span id="cb4-72"><a></a>        u_history.append(u_k)</span>
<span id="cb4-73"><a></a></span>
<span id="cb4-74"><a></a>        <span class="kw">def</span> ode_interval(t, y):</span>
<span id="cb4-75"><a></a>            <span class="cf">return</span> np.array([nonlinear_system(y[<span class="dv">0</span>], u_k)])</span>
<span id="cb4-76"><a></a></span>
<span id="cb4-77"><a></a>        t_interval <span class="op">=</span> (current_t, current_t <span class="op">+</span> Ts)</span>
<span id="cb4-78"><a></a>        sol_interval <span class="op">=</span> solve_ivp(</span>
<span id="cb4-79"><a></a>            ode_interval, t_interval, current_x, method<span class="op">=</span><span class="st">'RK45'</span>,</span>
<span id="cb4-80"><a></a>            t_eval<span class="op">=</span>[current_t <span class="op">+</span> Ts]</span>
<span id="cb4-81"><a></a>        )</span>
<span id="cb4-82"><a></a></span>
<span id="cb4-83"><a></a>        <span class="cf">if</span> sol_interval.status <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb4-84"><a></a>            <span class="bu">print</span>(<span class="ss">f"Simulation failed at step </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> (t=</span><span class="sc">{</span>current_t<span class="sc">:.2f}</span><span class="ss">) for x(0)=</span><span class="sc">{</span>x0_val<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-85"><a></a>            <span class="co"># Pad history...</span></span>
<span id="cb4-86"><a></a>            failed_steps <span class="op">=</span> n_steps <span class="op">-</span> k</span>
<span id="cb4-87"><a></a>            t_history.extend(np.linspace(current_t <span class="op">+</span> Ts, t_end, failed_steps))</span>
<span id="cb4-88"><a></a>            x_history.extend([np.nan] <span class="op">*</span> failed_steps)</span>
<span id="cb4-89"><a></a>            u_history.extend([np.nan] <span class="op">*</span> failed_steps)</span>
<span id="cb4-90"><a></a>            <span class="cf">break</span></span>
<span id="cb4-91"><a></a></span>
<span id="cb4-92"><a></a>        current_t <span class="op">+=</span> Ts</span>
<span id="cb4-93"><a></a>        current_x <span class="op">=</span> sol_interval.y[:, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb4-94"><a></a>        t_history.append(current_t)</span>
<span id="cb4-95"><a></a>        x_history.append(current_x[<span class="dv">0</span>])</span>
<span id="cb4-96"><a></a></span>
<span id="cb4-97"><a></a>        <span class="cf">if</span> <span class="bu">abs</span>(current_x[<span class="dv">0</span>]) <span class="op">&gt;</span> <span class="dv">10</span>: <span class="co"># Stop if diverging</span></span>
<span id="cb4-98"><a></a>            <span class="bu">print</span>(<span class="ss">f"State diverging at step </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> (t=</span><span class="sc">{</span>current_t<span class="sc">:.2f}</span><span class="ss">) for x(0)=</span><span class="sc">{</span>x0_val<span class="sc">}</span><span class="ss">. Stopping."</span>)</span>
<span id="cb4-99"><a></a>            failed_steps <span class="op">=</span> n_steps <span class="op">-</span> k <span class="op">-</span><span class="dv">1</span></span>
<span id="cb4-100"><a></a>            <span class="cf">if</span> failed_steps <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb4-101"><a></a>                 t_history.extend(np.linspace(current_t <span class="op">+</span> Ts, t_end, failed_steps))</span>
<span id="cb4-102"><a></a>                 x_history.extend([np.nan] <span class="op">*</span> failed_steps)</span>
<span id="cb4-103"><a></a>            <span class="cf">break</span></span>
<span id="cb4-104"><a></a></span>
<span id="cb4-105"><a></a>    <span class="cf">return</span> np.array(t_history), np.array(x_history), np.array(u_history)</span>
<span id="cb4-106"><a></a></span>
<span id="cb4-107"><a></a><span class="co"># Run both simulations with DLQR gain</span></span>
<span id="cb4-108"><a></a>t_small, x_small, u_small <span class="op">=</span> run_simulation(x0_small, K_lqr)</span>
<span id="cb4-109"><a></a>t_large, x_large, u_large <span class="op">=</span> run_simulation(x0_large, K_lqr)</span>
<span id="cb4-110"><a></a></span>
<span id="cb4-111"><a></a><span class="co"># 4. Plotting Results</span></span>
<span id="cb4-112"><a></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb4-113"><a></a>plt.subplot(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb4-114"><a></a>plt.plot(t_small, x_small, label<span class="op">=</span><span class="ss">f'State x(t) (x0=</span><span class="sc">{</span>x0_small<span class="sc">}</span><span class="ss">)'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb4-115"><a></a>plt.plot(t_large, x_large, label<span class="op">=</span><span class="ss">f'State x(t) (x0=</span><span class="sc">{</span>x0_large<span class="sc">}</span><span class="ss">)'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb4-116"><a></a>plt.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>, linestyle<span class="op">=</span><span class="st">':'</span>)</span>
<span id="cb4-117"><a></a>plt.ylabel(<span class="st">'State x'</span>)</span>
<span id="cb4-118"><a></a>plt.title(<span class="ss">f'Scalar Nonlinear System with DLQR Controller (Q=</span><span class="sc">{</span>Qd<span class="sc">}</span><span class="ss">, R=</span><span class="sc">{</span>Rd<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb4-119"><a></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb4-120"><a></a>plt.legend()</span>
<span id="cb4-121"><a></a>plt.ylim(<span class="bu">min</span>(np.nanmin(x_small), np.nanmin(x_large), <span class="op">-</span><span class="dv">1</span>) <span class="op">-</span> <span class="fl">0.5</span>, <span class="bu">max</span>(np.nanmax(x_small), np.nanmax(x_large), <span class="dv">1</span>) <span class="op">+</span> <span class="fl">0.5</span>)</span>
<span id="cb4-122"><a></a></span>
<span id="cb4-123"><a></a>plt.subplot(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb4-124"><a></a>final_idx_small <span class="op">=</span> <span class="bu">len</span>(u_small)</span>
<span id="cb4-125"><a></a><span class="cf">if</span> final_idx_small <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb4-126"><a></a>    <span class="co"># Use step plot for control signal visualization</span></span>
<span id="cb4-127"><a></a>    plt.step(t_small[:final_idx_small], u_small[:final_idx_small], where<span class="op">=</span><span class="st">'post'</span>,</span>
<span id="cb4-128"><a></a>             label<span class="op">=</span><span class="ss">f'Control u[k] (x0=</span><span class="sc">{</span>x0_small<span class="sc">}</span><span class="ss">)'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb4-129"><a></a></span>
<span id="cb4-130"><a></a>final_idx_large <span class="op">=</span> <span class="bu">len</span>(u_large)</span>
<span id="cb4-131"><a></a><span class="cf">if</span> final_idx_large <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb4-132"><a></a>    plt.step(t_large[:final_idx_large], u_large[:final_idx_large], where<span class="op">=</span><span class="st">'post'</span>,</span>
<span id="cb4-133"><a></a>             label<span class="op">=</span><span class="ss">f'Control u[k] (x0=</span><span class="sc">{</span>x0_large<span class="sc">}</span><span class="ss">)'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb4-134"><a></a></span>
<span id="cb4-135"><a></a>plt.ylabel(<span class="st">'Control Input u'</span>)</span>
<span id="cb4-136"><a></a>plt.xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb4-137"><a></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb4-138"><a></a>plt.legend()</span>
<span id="cb4-139"><a></a></span>
<span id="cb4-140"><a></a>plt.tight_layout()</span>
<span id="cb4-141"><a></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div><div class="column fragment">
<div class="cell-output cell-output-stdout">
<pre><code>DARE Solution S = 15.257 (for Q=10.0, R=0.1)
DLQR Gain K = 5.519
Linear Closed-Loop Pole = 0.381. (STABLE)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture9_files/figure-revealjs/cell-4-output-2.png"></p>
</figure>
</div>
</div>
</div></div>
</section>
<section id="mimo-example-of-dlqr-design" class="slide level2 smaller scrollable">
<h2>MIMO Example of DLQR Design</h2>
<p>Consider the MIMO system with two states and two inputs: <span class="math display">
\begin{align*} x(kT+T) &amp;= \begin{bmatrix} 1 &amp; 0.1 \\ 0 &amp; 0.8 \end{bmatrix} x(kT) + \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix} u(kT) \\ y(kT) &amp;= Cx(kT) + Du(kT) \end{align*}
</span></p>
<div id="bd364741" class="cell columns column-output-location" data-results="hold" data-execution_count="4">
<div class="column">
<div class="sourceCode cell-code" id="cb6" data-code-line-numbers=""><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-3"><a></a><span class="im">import</span> scipy.linalg <span class="im">as</span> linalg</span>
<span id="cb6-4"><a></a><span class="im">import</span> control <span class="im">as</span> ctrl</span>
<span id="cb6-5"><a></a><span class="co"># Create the system matrices</span></span>
<span id="cb6-6"><a></a>G <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="fl">0.1</span>], [<span class="dv">0</span>, <span class="fl">0.8</span>]])</span>
<span id="cb6-7"><a></a>H <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>]])</span>
<span id="cb6-8"><a></a>C <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>]]) <span class="co"># Outputs are the states</span></span>
<span id="cb6-9"><a></a>D <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>]])</span>
<span id="cb6-10"><a></a></span>
<span id="cb6-11"><a></a><span class="co"># Pole placement for MIMO system</span></span>
<span id="cb6-12"><a></a>K1 <span class="op">=</span> np.array([[<span class="fl">0.6</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="fl">0.2</span>]]) </span>
<span id="cb6-13"><a></a>K2 <span class="op">=</span> np.array([[<span class="fl">0.4</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="fl">0.4</span>]]) </span>
<span id="cb6-14"><a></a></span>
<span id="cb6-15"><a></a><span class="co"># QLQR design for MIMO system</span></span>
<span id="cb6-16"><a></a>Q <span class="op">=</span> np.array([[<span class="dv">10</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">10</span>]]) <span class="co"># State weight matrix</span></span>
<span id="cb6-17"><a></a>R <span class="op">=</span> np.array([[<span class="fl">0.1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="fl">0.1</span>]]) <span class="co"># Control weight matrix</span></span>
<span id="cb6-18"><a></a></span>
<span id="cb6-19"><a></a><span class="co"># Solve the Discrete Algebraic Riccati Equation (DARE)</span></span>
<span id="cb6-20"><a></a>S <span class="op">=</span> linalg.solve_discrete_are(G, H, Q, R) <span class="co"># S is the solution to the DARE</span></span>
<span id="cb6-21"><a></a><span class="co"># Calculate DLQR gain K</span></span>
<span id="cb6-22"><a></a>K3 <span class="op">=</span> np.linalg.inv(R <span class="op">+</span> H.T <span class="op">@</span> S <span class="op">@</span> H) <span class="op">@</span> (H.T <span class="op">@</span> S <span class="op">@</span> G)</span>
<span id="cb6-23"><a></a><span class="bu">print</span>(<span class="ss">f"K3 = [</span><span class="sc">{</span>K3[<span class="dv">0</span>, <span class="dv">0</span>]<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>K3[<span class="dv">0</span>, <span class="dv">1</span>]<span class="sc">:.3f}</span><span class="ss">; </span><span class="sc">{</span>K3[<span class="dv">1</span>, <span class="dv">0</span>]<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>K3[<span class="dv">1</span>, <span class="dv">1</span>]<span class="sc">:.3f}</span><span class="ss">]"</span>)</span>
<span id="cb6-24"><a></a><span class="bu">print</span>(<span class="ss">f"eig(G - H @ K3) = </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>eigvals(G <span class="op">-</span> H <span class="op">@</span> K3)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-25"><a></a></span>
<span id="cb6-26"><a></a><span class="co"># Compute the closed-loop system matrices</span></span>
<span id="cb6-27"><a></a>Gcl1 <span class="op">=</span> G <span class="op">-</span> H <span class="op">@</span> K1 </span>
<span id="cb6-28"><a></a>Gcl2 <span class="op">=</span> G <span class="op">-</span> H <span class="op">@</span> K2</span>
<span id="cb6-29"><a></a>Gcl3 <span class="op">=</span> G <span class="op">-</span> H <span class="op">@</span> K3</span>
<span id="cb6-30"><a></a></span>
<span id="cb6-31"><a></a>Ts <span class="op">=</span> <span class="fl">0.1</span> <span class="co"># Sampling time (seconds)</span></span>
<span id="cb6-32"><a></a><span class="co"># Create the closed-loop LTI systems</span></span>
<span id="cb6-33"><a></a>sys1 <span class="op">=</span> ctrl.ss(Gcl1, H, C, D, Ts) </span>
<span id="cb6-34"><a></a>sys2 <span class="op">=</span> ctrl.ss(Gcl2, H, C, D, Ts) </span>
<span id="cb6-35"><a></a>sys3 <span class="op">=</span> ctrl.ss(Gcl3, H, C, D, Ts)</span>
<span id="cb6-36"><a></a></span>
<span id="cb6-37"><a></a><span class="co"># Simulate for initial condition x0 = [1, 0]</span></span>
<span id="cb6-38"><a></a>x0 <span class="op">=</span> np.array([<span class="fl">1.5</span>, <span class="fl">0.5</span>])</span>
<span id="cb6-39"><a></a>t_end <span class="op">=</span> <span class="fl">1.5</span> </span>
<span id="cb6-40"><a></a>t <span class="op">=</span> np.arange(<span class="dv">0</span>, t_end, Ts) </span>
<span id="cb6-41"><a></a>t1, y1 <span class="op">=</span> ctrl.initial_response(sys1, T<span class="op">=</span>t, X0<span class="op">=</span>x0)</span>
<span id="cb6-42"><a></a>t2, y2 <span class="op">=</span> ctrl.initial_response(sys2, T<span class="op">=</span>t, X0<span class="op">=</span>x0)</span>
<span id="cb6-43"><a></a>t3, y3 <span class="op">=</span> ctrl.initial_response(sys3, T<span class="op">=</span>t, X0<span class="op">=</span>x0)</span>
<span id="cb6-44"><a></a></span>
<span id="cb6-45"><a></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb6-46"><a></a>plt.plot(t1, y1[<span class="dv">0</span>, :], label<span class="op">=</span><span class="st">'K1 - x1'</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb6-47"><a></a>plt.plot(t1, y1[<span class="dv">1</span>, :], label<span class="op">=</span><span class="st">'K1 - x2'</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb6-48"><a></a>plt.plot(t2, y2[<span class="dv">0</span>, :], label<span class="op">=</span><span class="st">'K2 - x1'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">3</span>) </span>
<span id="cb6-49"><a></a>plt.plot(t2, y2[<span class="dv">1</span>, :], label<span class="op">=</span><span class="st">'K2 - x2'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">3</span>) </span>
<span id="cb6-50"><a></a>plt.plot(t3, y3[<span class="dv">0</span>, :], label<span class="op">=</span><span class="st">'K3 - x1'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, linewidth<span class="op">=</span><span class="dv">3</span>) </span>
<span id="cb6-51"><a></a>plt.plot(t3, y3[<span class="dv">1</span>, :], label<span class="op">=</span><span class="st">'K3 - x2'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, linewidth<span class="op">=</span><span class="dv">3</span>) </span>
<span id="cb6-52"><a></a>plt.title(<span class="st">'Initial Condition Response ($x_0=[1, 0]^T$) with Different K Matrices'</span>, fontsize<span class="op">=</span><span class="dv">16</span>) </span>
<span id="cb6-53"><a></a>plt.xlabel(<span class="st">'Time (steps * dt)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>) </span>
<span id="cb6-54"><a></a>plt.ylabel(<span class="st">'State Values'</span>, fontsize<span class="op">=</span><span class="dv">14</span>) </span>
<span id="cb6-55"><a></a>plt.legend(fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb6-56"><a></a>plt.grid(<span class="va">True</span>) </span>
<span id="cb6-57"><a></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div><div class="column fragment">
<div class="cell-output cell-output-stdout">
<pre><code>K3 = [0.990, 0.099; 0.000, 0.792]
eig(G - H @ K3) = [0.00980006 0.0078745 ]</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture9_files/figure-revealjs/cell-5-output-2.png"></p>
</figure>
</div>
</div>
</div></div>
</section>
<section id="tuning-q-and-r-the-trade-off" class="slide level2">
<h2>Tuning Q and R: The Trade-off</h2>
<ul>
<li>The <strong>relative size</strong> (<span class="math inline">Q</span>/<span class="math inline">R</span> ratio) affects the <strong>trade-off</strong> between state regulation and control effort.</li>
<li>Increasing <span class="math inline">Q</span> relative to <span class="math inline">R</span> <span class="math inline">\rightarrow</span> increases the <strong>penalty on state deviation</strong>
<ul>
<li><strong>faster state convergence</strong>,</li>
<li><strong>higher control effort</strong>.</li>
</ul></li>
<li>Increasing <span class="math inline">R</span> relative to <span class="math inline">Q</span> <span class="math inline">\rightarrow</span> increases the <strong>penalty on control effort</strong>
<ul>
<li><strong>slower state convergence</strong>,</li>
<li><strong>lower control effort</strong>.</li>
</ul></li>
</ul>
</section>
<section id="quick-example-of-dlqr-tuning" class="slide level2">
<h2>Quick Example of DLQR Tuning</h2>
<div id="b9ed73b3" class="cell" data-code-block-height="300px" data-results="hold" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8" data-code-line-numbers=""><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a></a><span class="co"># Iterate over different Q values and simulate the system</span></span>
<span id="cb8-2"><a></a>Q_values <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">100</span>]  <span class="co"># Different state penalty values</span></span>
<span id="cb8-3"><a></a>R <span class="op">=</span> <span class="fl">0.1</span>  <span class="co"># Fixed control penalty</span></span>
<span id="cb8-4"><a></a>Ad <span class="op">=</span> <span class="fl">0.905</span></span>
<span id="cb8-5"><a></a>Bd <span class="op">=</span> <span class="fl">0.095</span></span>
<span id="cb8-6"><a></a>Ts <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb8-7"><a></a>x0 <span class="op">=</span> <span class="dv">2</span>  <span class="co"># Initial condition</span></span>
<span id="cb8-8"><a></a></span>
<span id="cb8-9"><a></a><span class="co"># Store results for plotting</span></span>
<span id="cb8-10"><a></a>results <span class="op">=</span> []</span>
<span id="cb8-11"><a></a></span>
<span id="cb8-12"><a></a><span class="cf">for</span> Q <span class="kw">in</span> Q_values:</span>
<span id="cb8-13"><a></a>  <span class="co"># Solve DARE for each Q</span></span>
<span id="cb8-14"><a></a>  S <span class="op">=</span> solve_discrete_are(np.array([[Ad]]), np.array([[Bd]]), np.array([[Q]]), np.array([[R]]))</span>
<span id="cb8-15"><a></a>  K <span class="op">=</span> np.linalg.inv(R <span class="op">+</span> Bd<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> S) <span class="op">@</span> (Bd <span class="op">*</span> S <span class="op">*</span> Ad)</span>
<span id="cb8-16"><a></a>  K <span class="op">=</span> K[<span class="dv">0</span>, <span class="dv">0</span>]  <span class="co"># Extract scalar gain</span></span>
<span id="cb8-17"><a></a></span>
<span id="cb8-18"><a></a>  <span class="co"># Simulate the system</span></span>
<span id="cb8-19"><a></a>  t_history <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb8-20"><a></a>  x_history <span class="op">=</span> [x0]</span>
<span id="cb8-21"><a></a>  current_x <span class="op">=</span> x0</span>
<span id="cb8-22"><a></a>  <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">50</span>):  <span class="co"># Simulate for 50 steps</span></span>
<span id="cb8-23"><a></a>    u <span class="op">=</span> <span class="op">-</span>K <span class="op">*</span> current_x</span>
<span id="cb8-24"><a></a>    current_x <span class="op">=</span> Ad <span class="op">*</span> current_x <span class="op">+</span> Bd <span class="op">*</span> u</span>
<span id="cb8-25"><a></a>    t_history.append((k <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> Ts)</span>
<span id="cb8-26"><a></a>    x_history.append(current_x)</span>
<span id="cb8-27"><a></a></span>
<span id="cb8-28"><a></a>  results.append((Q, t_history, x_history))</span>
<span id="cb8-29"><a></a></span>
<span id="cb8-30"><a></a><span class="co"># Plot results</span></span>
<span id="cb8-31"><a></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb8-32"><a></a><span class="cf">for</span> Q, t_history, x_history <span class="kw">in</span> results:</span>
<span id="cb8-33"><a></a>  plt.plot(t_history, x_history, label<span class="op">=</span><span class="ss">f"Q=</span><span class="sc">{</span>Q<span class="sc">}</span><span class="ss">"</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb8-34"><a></a></span>
<span id="cb8-35"><a></a>plt.title(<span class="st">"DLQR State Response for Different Q Values"</span>)</span>
<span id="cb8-36"><a></a>plt.xlabel(<span class="st">"Time (s)"</span>)</span>
<span id="cb8-37"><a></a>plt.ylabel(<span class="st">"State x"</span>)</span>
<span id="cb8-38"><a></a>plt.legend()</span>
<span id="cb8-39"><a></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb8-40"><a></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>

</div>
<img data-src="lecture9_files/figure-revealjs/cell-6-output-1.png" class="r-stretch"></section>
<section id="limitations-of-lqr-control-saturation" class="slide level2 smaller scrollable">
<h2>Limitations of LQR: Control Saturation</h2>
<!-- The *Linear* Quadratic Regulator may not be suitable for all systems, however. -->
<p>Consider the system <span class="math inline">\; \ddot x = x - c\dot x + u</span>, where <span class="math inline">u_{\min} \le u(kT) \le u_{\max}</span>.</p>
<div class="panel-tabset">
<ul id="tabset-1" class="panel-tabset-tabby"><li><a data-tabby-default="" href="#tabset-1-1">Unsaturated LQR</a></li><li><a href="#tabset-1-2">Saturated LQR</a></li><li><a href="#tabset-1-3">MPC</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1">
<div id="ad73ca70" class="cell columns column-output-location" data-execution_count="6">
<div class="column">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a></a><span class="co"># Scenario 1: Unconstrained LQR for Nonzero Regulation (Self-Contained)</span></span>
<span id="cb9-2"><a></a></span>
<span id="cb9-3"><a></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-4"><a></a><span class="im">from</span> scipy.integrate <span class="im">import</span> solve_ivp</span>
<span id="cb9-5"><a></a><span class="im">from</span> scipy.linalg <span class="im">import</span> solve_discrete_are</span>
<span id="cb9-6"><a></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb9-7"><a></a><span class="im">import</span> time</span>
<span id="cb9-8"><a></a></span>
<span id="cb9-9"><a></a><span class="co"># print("--- Running Scenario 1: Unconstrained LQR (Nonzero Setpoint) ---")</span></span>
<span id="cb9-10"><a></a></span>
<span id="cb9-11"><a></a><span class="co"># --- 1. System Definition ---</span></span>
<span id="cb9-12"><a></a><span class="co"># Stable continuous system: dx/dt = -x + u</span></span>
<span id="cb9-13"><a></a>a <span class="op">=</span> <span class="op">-</span><span class="fl">1.0</span></span>
<span id="cb9-14"><a></a>b <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb9-15"><a></a><span class="kw">def</span> system_ode(t, x, u, a_par, b_par):</span>
<span id="cb9-16"><a></a>    <span class="co"># x is a 1-element array</span></span>
<span id="cb9-17"><a></a>    <span class="cf">return</span> a_par <span class="op">*</span> x[<span class="dv">0</span>] <span class="op">+</span> b_par <span class="op">*</span> u</span>
<span id="cb9-18"><a></a></span>
<span id="cb9-19"><a></a><span class="co"># --- 2. Discretization ---</span></span>
<span id="cb9-20"><a></a>Ts <span class="op">=</span> <span class="fl">0.1</span> <span class="co"># Sampling time</span></span>
<span id="cb9-21"><a></a>Ac <span class="op">=</span> np.array([[a]])</span>
<span id="cb9-22"><a></a>Bc <span class="op">=</span> np.array([[b]])</span>
<span id="cb9-23"><a></a>Ad <span class="op">=</span> np.array([[np.exp(a <span class="op">*</span> Ts)]])</span>
<span id="cb9-24"><a></a>Bd <span class="op">=</span> np.array([[(np.exp(a <span class="op">*</span> Ts) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> a <span class="op">*</span> b]])</span>
<span id="cb9-25"><a></a>n_states <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-26"><a></a>m_inputs <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-27"><a></a><span class="co"># print(f"Discrete System: Ad = {Ad[0,0]:.3f}, Bd = {Bd[0,0]:.3f}")</span></span>
<span id="cb9-28"><a></a></span>
<span id="cb9-29"><a></a><span class="co"># --- 3. Setpoint ---</span></span>
<span id="cb9-30"><a></a>x_ref <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb9-31"><a></a>u_ref <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> Ad[<span class="dv">0</span>,<span class="dv">0</span>]) <span class="op">/</span> Bd[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">*</span> x_ref <span class="co"># Calculate for discrete system</span></span>
<span id="cb9-32"><a></a><span class="co"># print(f"Setpoint: x_ref = {x_ref:.2f}, requires u_ref = {u_ref:.2f}")</span></span>
<span id="cb9-33"><a></a>x_eq_ref <span class="op">=</span> np.array([x_ref]) <span class="co"># Target state for reference</span></span>
<span id="cb9-34"><a></a></span>
<span id="cb9-35"><a></a><span class="co"># --- 4. DLQR Design (for error regulation) ---</span></span>
<span id="cb9-36"><a></a><span class="co"># Weights for error cost: sum(Qd*xtilde^2 + Rd*utilde^2)</span></span>
<span id="cb9-37"><a></a>Qd <span class="op">=</span> <span class="fl">10.0</span></span>
<span id="cb9-38"><a></a>Rd <span class="op">=</span> <span class="fl">1.0</span> <span class="co"># Using less aggressive weights</span></span>
<span id="cb9-39"><a></a>Q_dare <span class="op">=</span> np.array([[Qd]])</span>
<span id="cb9-40"><a></a>R_dare <span class="op">=</span> np.array([[Rd]])</span>
<span id="cb9-41"><a></a><span class="cf">try</span>:</span>
<span id="cb9-42"><a></a>    S <span class="op">=</span> solve_discrete_are(Ad, Bd, Q_dare, R_dare)</span>
<span id="cb9-43"><a></a>    Kd_term1 <span class="op">=</span> R_dare <span class="op">+</span> Bd.T <span class="op">@</span> S <span class="op">@</span> Bd</span>
<span id="cb9-44"><a></a>    Kd_term2 <span class="op">=</span> Bd.T <span class="op">@</span> S <span class="op">@</span> Ad</span>
<span id="cb9-45"><a></a>    Kd <span class="op">=</span> np.linalg.inv(Kd_term1) <span class="op">@</span> Kd_term2</span>
<span id="cb9-46"><a></a>    K_lqr <span class="op">=</span> Kd[<span class="dv">0</span>, <span class="dv">0</span>] <span class="co"># Scalar gain for error feedback</span></span>
<span id="cb9-47"><a></a>    <span class="bu">print</span>(<span class="ss">f"DLQR Gain for error K = </span><span class="sc">{</span>K_lqr<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb9-48"><a></a><span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb9-49"><a></a>    <span class="bu">print</span>(<span class="ss">f"DLQR Design failed: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)<span class="op">;</span> exit()</span>
<span id="cb9-50"><a></a></span>
<span id="cb9-51"><a></a></span>
<span id="cb9-52"><a></a><span class="bu">print</span>(<span class="ss">f"Control Limits: [-inf, inf]"</span>)</span>
<span id="cb9-53"><a></a></span>
<span id="cb9-54"><a></a><span class="co"># --- 5. Simulation Setup ---</span></span>
<span id="cb9-55"><a></a>t_start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-56"><a></a>t_end <span class="op">=</span> <span class="fl">5.0</span></span>
<span id="cb9-57"><a></a>n_steps <span class="op">=</span> <span class="bu">int</span>(t_end <span class="op">/</span> Ts)</span>
<span id="cb9-58"><a></a>x0 <span class="op">=</span> <span class="fl">0.0</span> <span class="co"># Initial condition (start from origin)</span></span>
<span id="cb9-59"><a></a></span>
<span id="cb9-60"><a></a><span class="co"># --- Helper function for interval simulation ---</span></span>
<span id="cb9-61"><a></a><span class="kw">def</span> simulate_interval(ode_func, t_start, x_start, duration, control_val):</span>
<span id="cb9-62"><a></a>    t_eval_interval <span class="op">=</span> [t_start <span class="op">+</span> duration]</span>
<span id="cb9-63"><a></a>    sol_interval <span class="op">=</span> solve_ivp(</span>
<span id="cb9-64"><a></a>        ode_func, (t_start, t_start <span class="op">+</span> duration), x_start, method<span class="op">=</span><span class="st">'RK45'</span>,</span>
<span id="cb9-65"><a></a>        t_eval<span class="op">=</span>t_eval_interval, args<span class="op">=</span>(control_val,)</span>
<span id="cb9-66"><a></a>    )</span>
<span id="cb9-67"><a></a>    <span class="cf">if</span> sol_interval.status <span class="op">!=</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="va">None</span>, <span class="va">False</span></span>
<span id="cb9-68"><a></a>    <span class="cf">return</span> sol_interval.y[:, <span class="op">-</span><span class="dv">1</span>], <span class="va">True</span></span>
<span id="cb9-69"><a></a></span>
<span id="cb9-70"><a></a><span class="co"># --- 6. Simulation Loop ---</span></span>
<span id="cb9-71"><a></a>t_history <span class="op">=</span> [t_start]</span>
<span id="cb9-72"><a></a>x_history <span class="op">=</span> [np.array([x0])] <span class="co"># Store as list of arrays</span></span>
<span id="cb9-73"><a></a>u_history <span class="op">=</span> []</span>
<span id="cb9-74"><a></a>current_t <span class="op">=</span> t_start</span>
<span id="cb9-75"><a></a>current_x <span class="op">=</span> np.array([x0])</span>
<span id="cb9-76"><a></a>success_run <span class="op">=</span> <span class="va">True</span></span>
<span id="cb9-77"><a></a></span>
<span id="cb9-78"><a></a>start_sim_time <span class="op">=</span> time.time()</span>
<span id="cb9-79"><a></a><span class="co"># print("Running simulation...")</span></span>
<span id="cb9-80"><a></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb9-81"><a></a>    x_error <span class="op">=</span> current_x[<span class="dv">0</span>] <span class="op">-</span> x_ref</span>
<span id="cb9-82"><a></a>    <span class="co"># Control Law: u[k] = u_ref - K*(x[k]-x_ref)</span></span>
<span id="cb9-83"><a></a>    u_k <span class="op">=</span> u_ref <span class="op">-</span> K_lqr <span class="op">*</span> x_error</span>
<span id="cb9-84"><a></a>    <span class="co"># NO SATURATION APPLIED HERE</span></span>
<span id="cb9-85"><a></a>    u_history.append(u_k)</span>
<span id="cb9-86"><a></a></span>
<span id="cb9-87"><a></a>    <span class="kw">def</span> ode_lqr_interval(t, y, u_val):</span>
<span id="cb9-88"><a></a>        <span class="cf">return</span> system_ode(t, y, u_val, a, b)</span>
<span id="cb9-89"><a></a></span>
<span id="cb9-90"><a></a>    next_x, success <span class="op">=</span> simulate_interval(ode_lqr_interval, current_t, current_x, Ts, u_k)</span>
<span id="cb9-91"><a></a></span>
<span id="cb9-92"><a></a>    <span class="cf">if</span> <span class="kw">not</span> success:</span>
<span id="cb9-93"><a></a>        <span class="bu">print</span>(<span class="ss">f"ODE solver failed at t=</span><span class="sc">{</span>current_t<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb9-94"><a></a>        success_run <span class="op">=</span> <span class="va">False</span><span class="op">;</span> <span class="cf">break</span></span>
<span id="cb9-95"><a></a></span>
<span id="cb9-96"><a></a>    current_t <span class="op">+=</span> Ts</span>
<span id="cb9-97"><a></a>    current_x <span class="op">=</span> next_x</span>
<span id="cb9-98"><a></a>    t_history.append(current_t)</span>
<span id="cb9-99"><a></a>    x_history.append(current_x.copy()) <span class="co"># Append copy</span></span>
<span id="cb9-100"><a></a></span>
<span id="cb9-101"><a></a>    <span class="cf">if</span> np.<span class="bu">max</span>(np.<span class="bu">abs</span>(current_x)) <span class="op">&gt;</span> <span class="dv">100</span>: <span class="co"># Divergence check</span></span>
<span id="cb9-102"><a></a>        <span class="bu">print</span>(<span class="ss">f"State diverging excessively at t=</span><span class="sc">{</span>current_t<span class="sc">:.2f}</span><span class="ss">. Stopping."</span>)</span>
<span id="cb9-103"><a></a>        success_run <span class="op">=</span> <span class="va">False</span><span class="op">;</span> <span class="cf">break</span></span>
<span id="cb9-104"><a></a></span>
<span id="cb9-105"><a></a><span class="bu">print</span>(<span class="ss">f"Simulation loop time: </span><span class="sc">{</span>time<span class="sc">.</span>time() <span class="op">-</span> start_sim_time<span class="sc">:.2f}</span><span class="ss"> s"</span>)</span>
<span id="cb9-106"><a></a></span>
<span id="cb9-107"><a></a><span class="co"># --- 7. Plotting ---</span></span>
<span id="cb9-108"><a></a><span class="cf">if</span> success_run:</span>
<span id="cb9-109"><a></a>    t_history <span class="op">=</span> np.array(t_history)</span>
<span id="cb9-110"><a></a>    x_history <span class="op">=</span> np.array(x_history).T[<span class="dv">0</span>,:] <span class="co"># Extract scalar state history</span></span>
<span id="cb9-111"><a></a>    u_history <span class="op">=</span> np.array(u_history)</span>
<span id="cb9-112"><a></a>    n_plot <span class="op">=</span> <span class="bu">len</span>(u_history) <span class="co"># Successful steps</span></span>
<span id="cb9-113"><a></a></span>
<span id="cb9-114"><a></a>    <span class="co"># Define consistent plot limits</span></span>
<span id="cb9-115"><a></a>    xlims <span class="op">=</span> (t_start, t_end)</span>
<span id="cb9-116"><a></a>    ylims_x <span class="op">=</span> (<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">2.5</span>)</span>
<span id="cb9-117"><a></a>    ylims_u <span class="op">=</span> (<span class="op">-</span><span class="fl">3.5</span>, <span class="fl">5.5</span>) <span class="co"># Wider range to potentially show large unconstrained values</span></span>
<span id="cb9-118"><a></a></span>
<span id="cb9-119"><a></a>    plt.figure(<span class="st">"Unconstrained LQR (Nonzero Setpoint)"</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb9-120"><a></a>    plt.rcParams.update({<span class="st">'font.size'</span>: <span class="dv">12</span>})</span>
<span id="cb9-121"><a></a></span>
<span id="cb9-122"><a></a>    plt.subplot(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb9-123"><a></a>    plt.plot(t_history[:n_plot<span class="op">+</span><span class="dv">1</span>], x_history[:n_plot<span class="op">+</span><span class="dv">1</span>], label<span class="op">=</span><span class="st">'State x(t)'</span>, lw<span class="op">=</span><span class="dv">2</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb9-124"><a></a>    plt.axhline(x_ref, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, label<span class="op">=</span><span class="ss">f'Setpoint x=</span><span class="sc">{</span>x_ref<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb9-125"><a></a>    plt.ylabel(<span class="st">'State x'</span>)</span>
<span id="cb9-126"><a></a>    plt.title(<span class="ss">f'Unconstrained LQR (Setpoint x=</span><span class="sc">{</span>x_ref<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb9-127"><a></a>    plt.ylim(ylims_x)<span class="op">;</span> plt.xlim(xlims)<span class="op">;</span> plt.grid(<span class="va">True</span>)<span class="op">;</span> plt.legend()</span>
<span id="cb9-128"><a></a></span>
<span id="cb9-129"><a></a>    plt.subplot(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb9-130"><a></a>    plt.step(t_history[:n_plot], u_history[:n_plot], where<span class="op">=</span><span class="st">'post'</span>, label<span class="op">=</span><span class="st">'Control u[k]'</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb9-131"><a></a>    plt.axhline(u_ref, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, label<span class="op">=</span><span class="ss">f'Steady-State u=</span><span class="sc">{</span>u_ref<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb9-132"><a></a>    plt.ylabel(<span class="st">'Control Input u'</span>)</span>
<span id="cb9-133"><a></a>    plt.xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb9-134"><a></a>    plt.ylim(ylims_u)<span class="op">;</span> plt.xlim(xlims)<span class="op">;</span> plt.grid(<span class="va">True</span>)<span class="op">;</span> plt.legend()</span>
<span id="cb9-135"><a></a></span>
<span id="cb9-136"><a></a>    plt.tight_layout()</span>
<span id="cb9-137"><a></a>    plt.show()</span>
<span id="cb9-138"><a></a><span class="cf">else</span>:</span>
<span id="cb9-139"><a></a>    <span class="bu">print</span>(<span class="st">"Simulation failed, not plotting."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div><div class="column">
<div class="cell-output cell-output-stdout">
<pre><code>DLQR Gain for error K = 1.956
Control Limits: [-inf, inf]
Simulation loop time: 0.02 s</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture9_files/figure-revealjs/cell-7-output-2.png"></p>
</figure>
</div>
</div>
</div></div>
</div>
<div id="tabset-1-2">
<div id="5fb061f1" class="cell columns column-output-location" data-execution_count="7">
<div class="column">
<div class="sourceCode cell-code" id="cb11" data-code-line-numbers=""><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a></a><span class="co"># Scenario 2: Saturated LQR for Nonzero Regulation (Damped 2nd Order System)</span></span>
<span id="cb11-2"><a></a></span>
<span id="cb11-3"><a></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb11-4"><a></a><span class="im">from</span> scipy.integrate <span class="im">import</span> solve_ivp</span>
<span id="cb11-5"><a></a><span class="im">from</span> scipy.linalg <span class="im">import</span> solve_discrete_are, expm</span>
<span id="cb11-6"><a></a><span class="im">from</span> scipy.signal <span class="im">import</span> cont2discrete</span>
<span id="cb11-7"><a></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb11-8"><a></a><span class="im">import</span> time</span>
<span id="cb11-9"><a></a></span>
<span id="cb11-10"><a></a><span class="co"># print("--- Running Scenario 2: Saturated LQR (Nonzero Setpoint, Damped System) ---")</span></span>
<span id="cb11-11"><a></a></span>
<span id="cb11-12"><a></a><span class="co"># --- 1. System Definition ---</span></span>
<span id="cb11-13"><a></a>c_damping <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb11-14"><a></a>Ac <span class="op">=</span> np.array([[<span class="fl">0.</span>, <span class="fl">1.</span>], [<span class="fl">1.</span>, <span class="op">-</span>c_damping]])</span>
<span id="cb11-15"><a></a>Bc <span class="op">=</span> np.array([[<span class="fl">0.</span>], [<span class="fl">1.</span>]])</span>
<span id="cb11-16"><a></a>n_states <span class="op">=</span> Ac.shape[<span class="dv">0</span>]</span>
<span id="cb11-17"><a></a>m_inputs <span class="op">=</span> Bc.shape[<span class="dv">1</span>]</span>
<span id="cb11-18"><a></a><span class="kw">def</span> system_ode(t, x, u, Ac_mat, Bc_mat):</span>
<span id="cb11-19"><a></a>    u_val <span class="op">=</span> u <span class="cf">if</span> np.isscalar(u) <span class="cf">else</span> u[<span class="dv">0</span>]</span>
<span id="cb11-20"><a></a>    dxdt <span class="op">=</span> Ac_mat <span class="op">@</span> x <span class="op">+</span> Bc_mat <span class="op">@</span> np.array([u_val])</span>
<span id="cb11-21"><a></a>    <span class="cf">return</span> dxdt.flatten()</span>
<span id="cb11-22"><a></a></span>
<span id="cb11-23"><a></a><span class="co"># --- 2. Discretization ---</span></span>
<span id="cb11-24"><a></a>Ts <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb11-25"><a></a>Ad, Bd, _, _, _ <span class="op">=</span> cont2discrete((Ac, Bc, np.eye(n_states), np.zeros((n_states, m_inputs))), Ts, method<span class="op">=</span><span class="st">'zoh'</span>)</span>
<span id="cb11-26"><a></a></span>
<span id="cb11-27"><a></a><span class="co"># --- 3. Setpoint ---</span></span>
<span id="cb11-28"><a></a>x_ref <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="fl">0.0</span>])</span>
<span id="cb11-29"><a></a><span class="cf">try</span>:</span>
<span id="cb11-30"><a></a>    u_ref_vec <span class="op">=</span> np.linalg.pinv(Bd) <span class="op">@</span> (np.eye(n_states) <span class="op">-</span> Ad) <span class="op">@</span> x_ref</span>
<span id="cb11-31"><a></a>    u_ref <span class="op">=</span> u_ref_vec[<span class="dv">0</span>]</span>
<span id="cb11-32"><a></a>    <span class="co"># print(f"Setpoint: x_ref = {x_ref.T}, requires discrete u_ref = {u_ref:.3f} (cont. u_ref=-1.0)")</span></span>
<span id="cb11-33"><a></a><span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb11-34"><a></a>    <span class="bu">print</span>(<span class="ss">f"Could not calculate discrete u_ref: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">. Using continuous u_ref."</span>)</span>
<span id="cb11-35"><a></a>    u_ref <span class="op">=</span> <span class="op">-</span>x_ref[<span class="dv">0</span>]</span>
<span id="cb11-36"><a></a></span>
<span id="cb11-37"><a></a><span class="co"># --- 4. DLQR Design (for error regulation) ---</span></span>
<span id="cb11-38"><a></a>Qd <span class="op">=</span> np.diag([<span class="fl">1.0</span>, <span class="fl">0.1</span>])</span>
<span id="cb11-39"><a></a>Rd <span class="op">=</span> np.array([[<span class="fl">0.01</span>]])</span>
<span id="cb11-40"><a></a><span class="cf">try</span>:</span>
<span id="cb11-41"><a></a>    S <span class="op">=</span> solve_discrete_are(Ad, Bd, Qd, Rd)</span>
<span id="cb11-42"><a></a>    Kd_term1 <span class="op">=</span> Rd <span class="op">+</span> Bd.T <span class="op">@</span> S <span class="op">@</span> Bd</span>
<span id="cb11-43"><a></a>    Kd_term2 <span class="op">=</span> Bd.T <span class="op">@</span> S <span class="op">@</span> Ad</span>
<span id="cb11-44"><a></a>    Kd <span class="op">=</span> np.linalg.inv(Kd_term1) <span class="op">@</span> Kd_term2</span>
<span id="cb11-45"><a></a>    <span class="bu">print</span>(<span class="ss">f"DLQR Gain for error K = </span><span class="sc">{</span>Kd<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-46"><a></a><span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb11-47"><a></a>    <span class="bu">print</span>(<span class="ss">f"DLQR Design failed: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)<span class="op">;</span> exit()</span>
<span id="cb11-48"><a></a></span>
<span id="cb11-49"><a></a><span class="co"># --- 5. Simulation Setup ---</span></span>
<span id="cb11-50"><a></a>t_start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-51"><a></a>t_end <span class="op">=</span> <span class="fl">6.0</span></span>
<span id="cb11-52"><a></a>n_steps <span class="op">=</span> <span class="bu">int</span>(t_end <span class="op">/</span> Ts)</span>
<span id="cb11-53"><a></a>x0 <span class="op">=</span> np.array([<span class="fl">0.0</span>, <span class="fl">0.0</span>])</span>
<span id="cb11-54"><a></a>x_eq_ref <span class="op">=</span> np.array([x_ref]) <span class="co"># Use as reference, not equilibrium for deviation calc</span></span>
<span id="cb11-55"><a></a>u_min <span class="op">=</span> <span class="op">-</span><span class="fl">2.5</span> <span class="co"># Saturation Limits (Allow u_ref=-1)</span></span>
<span id="cb11-56"><a></a>u_max <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb11-57"><a></a><span class="bu">print</span>(<span class="ss">f"Control Limits: [</span><span class="sc">{</span>u_min<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>u_max<span class="sc">}</span><span class="ss">]"</span>)</span>
<span id="cb11-58"><a></a></span>
<span id="cb11-59"><a></a><span class="co"># --- Helper function for interval simulation ---</span></span>
<span id="cb11-60"><a></a><span class="kw">def</span> simulate_interval(ode_func, t_start, x_start, duration, control_val):</span>
<span id="cb11-61"><a></a>    t_eval_interval <span class="op">=</span> [t_start <span class="op">+</span> duration]</span>
<span id="cb11-62"><a></a>    sol_interval <span class="op">=</span> solve_ivp(</span>
<span id="cb11-63"><a></a>        ode_func, (t_start, t_start <span class="op">+</span> duration), x_start, method<span class="op">=</span><span class="st">'RK45'</span>,</span>
<span id="cb11-64"><a></a>        t_eval<span class="op">=</span>t_eval_interval, args<span class="op">=</span>(control_val,)</span>
<span id="cb11-65"><a></a>    )</span>
<span id="cb11-66"><a></a>    <span class="cf">if</span> sol_interval.status <span class="op">!=</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="va">None</span>, <span class="va">False</span></span>
<span id="cb11-67"><a></a>    <span class="cf">return</span> sol_interval.y[:, <span class="op">-</span><span class="dv">1</span>], <span class="va">True</span></span>
<span id="cb11-68"><a></a></span>
<span id="cb11-69"><a></a><span class="co"># --- 6. Simulation Loop ---</span></span>
<span id="cb11-70"><a></a>t_history <span class="op">=</span> [t_start]</span>
<span id="cb11-71"><a></a>x_history <span class="op">=</span> [x0]</span>
<span id="cb11-72"><a></a>u_lqr_desired_hist <span class="op">=</span> []</span>
<span id="cb11-73"><a></a>u_sat_applied_hist <span class="op">=</span> []</span>
<span id="cb11-74"><a></a>current_t <span class="op">=</span> t_start</span>
<span id="cb11-75"><a></a>current_x <span class="op">=</span> x0.copy()</span>
<span id="cb11-76"><a></a>success_run <span class="op">=</span> <span class="va">True</span></span>
<span id="cb11-77"><a></a></span>
<span id="cb11-78"><a></a>start_sim_time <span class="op">=</span> time.time()</span>
<span id="cb11-79"><a></a><span class="co"># print("Running simulation...")</span></span>
<span id="cb11-80"><a></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb11-81"><a></a>    x_error <span class="op">=</span> current_x <span class="op">-</span> x_ref</span>
<span id="cb11-82"><a></a>    <span class="co"># Calculate desired LQR control</span></span>
<span id="cb11-83"><a></a>    u_lqr_k_vec <span class="op">=</span> u_ref <span class="op">-</span> Kd <span class="op">@</span> x_error</span>
<span id="cb11-84"><a></a>    u_lqr_k <span class="op">=</span> u_lqr_k_vec[<span class="dv">0</span>]</span>
<span id="cb11-85"><a></a>    u_lqr_desired_hist.append(u_lqr_k)</span>
<span id="cb11-86"><a></a></span>
<span id="cb11-87"><a></a>    <span class="co"># Apply saturation</span></span>
<span id="cb11-88"><a></a>    u_sat_k <span class="op">=</span> np.clip(u_lqr_k, u_min, u_max)</span>
<span id="cb11-89"><a></a>    u_sat_applied_hist.append(u_sat_k)</span>
<span id="cb11-90"><a></a></span>
<span id="cb11-91"><a></a>    <span class="kw">def</span> ode_satlqr_interval(t, y, u_val):</span>
<span id="cb11-92"><a></a>        <span class="cf">return</span> system_ode(t, y, u_val, Ac, Bc)</span>
<span id="cb11-93"><a></a></span>
<span id="cb11-94"><a></a>    next_x, success <span class="op">=</span> simulate_interval(ode_satlqr_interval, current_t, current_x, Ts, u_sat_k)</span>
<span id="cb11-95"><a></a></span>
<span id="cb11-96"><a></a>    <span class="cf">if</span> <span class="kw">not</span> success:</span>
<span id="cb11-97"><a></a>        <span class="bu">print</span>(<span class="ss">f"ODE solver failed at t=</span><span class="sc">{</span>current_t<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb11-98"><a></a>        success_run <span class="op">=</span> <span class="va">False</span><span class="op">;</span> <span class="cf">break</span></span>
<span id="cb11-99"><a></a></span>
<span id="cb11-100"><a></a>    current_t <span class="op">+=</span> Ts</span>
<span id="cb11-101"><a></a>    current_x <span class="op">=</span> next_x</span>
<span id="cb11-102"><a></a>    t_history.append(current_t)</span>
<span id="cb11-103"><a></a>    x_history.append(current_x.copy())</span>
<span id="cb11-104"><a></a></span>
<span id="cb11-105"><a></a>    <span class="cf">if</span> np.<span class="bu">max</span>(np.<span class="bu">abs</span>(current_x)) <span class="op">&gt;</span> <span class="dv">100</span>: <span class="co"># Divergence check</span></span>
<span id="cb11-106"><a></a>        <span class="bu">print</span>(<span class="ss">f"State diverging excessively at t=</span><span class="sc">{</span>current_t<span class="sc">:.2f}</span><span class="ss">. Stopping."</span>)</span>
<span id="cb11-107"><a></a>        success_run <span class="op">=</span> <span class="va">False</span><span class="op">;</span> <span class="cf">break</span></span>
<span id="cb11-108"><a></a></span>
<span id="cb11-109"><a></a><span class="bu">print</span>(<span class="ss">f"Simulation loop time: </span><span class="sc">{</span>time<span class="sc">.</span>time() <span class="op">-</span> start_sim_time<span class="sc">:.2f}</span><span class="ss"> s"</span>)</span>
<span id="cb11-110"><a></a></span>
<span id="cb11-111"><a></a><span class="co"># --- 7. Plotting ---</span></span>
<span id="cb11-112"><a></a><span class="cf">if</span> success_run:</span>
<span id="cb11-113"><a></a>    t_history <span class="op">=</span> np.array(t_history)</span>
<span id="cb11-114"><a></a>    x_history <span class="op">=</span> np.array(x_history).T</span>
<span id="cb11-115"><a></a>    u_lqr_desired_hist <span class="op">=</span> np.array(u_lqr_desired_hist)</span>
<span id="cb11-116"><a></a>    u_sat_applied_hist <span class="op">=</span> np.array(u_sat_applied_hist)</span>
<span id="cb11-117"><a></a>    n_plot <span class="op">=</span> <span class="bu">len</span>(u_sat_applied_hist)</span>
<span id="cb11-118"><a></a></span>
<span id="cb11-119"><a></a>    <span class="co"># Use consistent plot limits from Block 1 (or adjust if needed)</span></span>
<span id="cb11-120"><a></a>    xlims <span class="op">=</span> (t_start, t_end)</span>
<span id="cb11-121"><a></a>    ylims_x1 <span class="op">=</span> (<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">1.5</span>)</span>
<span id="cb11-122"><a></a>    ylims_x2 <span class="op">=</span> (<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">1.5</span>)</span>
<span id="cb11-123"><a></a>    ylims_u <span class="op">=</span> (<span class="op">-</span><span class="dv">4</span>, <span class="dv">1</span>) <span class="co"># Keep wide limits to see desired vs saturated</span></span>
<span id="cb11-124"><a></a></span>
<span id="cb11-125"><a></a>    plt.figure(<span class="st">"Saturated LQR (Nonzero Setpoint, Damped)"</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">9</span>))</span>
<span id="cb11-126"><a></a>    plt.rcParams.update({<span class="st">'font.size'</span>: <span class="dv">12</span>})</span>
<span id="cb11-127"><a></a></span>
<span id="cb11-128"><a></a>    plt.subplot(<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb11-129"><a></a>    plt.plot(t_history[:n_plot<span class="op">+</span><span class="dv">1</span>], x_history[<span class="dv">0</span>,:n_plot<span class="op">+</span><span class="dv">1</span>], label<span class="op">=</span><span class="st">'$x_1$ (y)'</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb11-130"><a></a>    plt.axhline(x_ref[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, label<span class="op">=</span><span class="ss">f'Setpoint $x_1=</span><span class="sc">{</span>x_ref[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">$'</span>)</span>
<span id="cb11-131"><a></a>    plt.title(<span class="ss">f'Saturated LQR (Setpoint x=[</span><span class="sc">{</span>x_ref[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">,</span><span class="sc">{</span>x_ref[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">]^T, u limits=[</span><span class="sc">{</span>u_min<span class="sc">}</span><span class="ss">,</span><span class="sc">{</span>u_max<span class="sc">}</span><span class="ss">])'</span>)</span>
<span id="cb11-132"><a></a>    plt.ylabel(<span class="st">'Position $x_1$'</span>)</span>
<span id="cb11-133"><a></a>    plt.ylim(ylims_x1)<span class="op">;</span> plt.xlim(xlims)<span class="op">;</span> plt.grid(<span class="va">True</span>)<span class="op">;</span> plt.legend()</span>
<span id="cb11-134"><a></a></span>
<span id="cb11-135"><a></a>    plt.subplot(<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb11-136"><a></a>    plt.plot(t_history[:n_plot<span class="op">+</span><span class="dv">1</span>], x_history[<span class="dv">1</span>,:n_plot<span class="op">+</span><span class="dv">1</span>], label<span class="op">=</span><span class="st">'$x_2$ (dy/dt)'</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb11-137"><a></a>    plt.axhline(x_ref[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, label<span class="op">=</span><span class="ss">f'Setpoint $x_2=</span><span class="sc">{</span>x_ref[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">$'</span>)</span>
<span id="cb11-138"><a></a>    plt.ylabel(<span class="st">'Velocity $x_2$'</span>)</span>
<span id="cb11-139"><a></a>    plt.ylim(ylims_x2)<span class="op">;</span> plt.xlim(xlims)<span class="op">;</span> plt.grid(<span class="va">True</span>)<span class="op">;</span> plt.legend()</span>
<span id="cb11-140"><a></a></span>
<span id="cb11-141"><a></a>    plt.subplot(<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb11-142"><a></a>    plt.step(t_history[:n_plot], u_lqr_desired_hist[:n_plot], where<span class="op">=</span><span class="st">'post'</span>, label<span class="op">=</span><span class="st">'Desired LQR u[k]'</span>, lw<span class="op">=</span><span class="fl">1.5</span>, ls<span class="op">=</span><span class="st">':'</span>)</span>
<span id="cb11-143"><a></a>    plt.step(t_history[:n_plot], u_sat_applied_hist[:n_plot], where<span class="op">=</span><span class="st">'post'</span>, label<span class="op">=</span><span class="st">'Applied Saturated u[k]'</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb11-144"><a></a>    plt.axhline(u_ref, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, label<span class="op">=</span><span class="ss">f'Steady-State u=</span><span class="sc">{</span>u_ref<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb11-145"><a></a>    plt.axhline(u_max, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, label<span class="op">=</span><span class="st">'Limit'</span>)</span>
<span id="cb11-146"><a></a>    plt.axhline(u_min, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">':'</span>)</span>
<span id="cb11-147"><a></a>    plt.ylabel(<span class="st">'Control Input u'</span>)</span>
<span id="cb11-148"><a></a>    plt.xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb11-149"><a></a>    plt.ylim(ylims_u)<span class="op">;</span> plt.xlim(xlims)<span class="op">;</span> plt.grid(<span class="va">True</span>)<span class="op">;</span> plt.legend()</span>
<span id="cb11-150"><a></a></span>
<span id="cb11-151"><a></a>    plt.tight_layout()</span>
<span id="cb11-152"><a></a>    plt.show()</span>
<span id="cb11-153"><a></a><span class="cf">else</span>:</span>
<span id="cb11-154"><a></a>    <span class="bu">print</span>(<span class="st">"Simulation failed, not plotting."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div><div class="column">
<div class="cell-output cell-output-stdout">
<pre><code>DLQR Gain for error K = [[8.76224795 4.36193866]]
Control Limits: [-2.5, 0.5]
Simulation loop time: 0.03 s</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture9_files/figure-revealjs/cell-8-output-2.png"></p>
</figure>
</div>
</div>
</div></div>
</div>
<div id="tabset-1-3">
<div id="6dda2b3d" class="cell columns column-output-location" data-execution_count="8">
<div class="column">
<div class="sourceCode cell-code" id="cb13" data-code-line-numbers=""><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a></a><span class="co"># Scenario 3: MPC for Nonzero Regulation (Damped 2nd Order System)</span></span>
<span id="cb13-2"><a></a></span>
<span id="cb13-3"><a></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-4"><a></a><span class="im">from</span> scipy.integrate <span class="im">import</span> solve_ivp</span>
<span id="cb13-5"><a></a><span class="im">from</span> scipy.linalg <span class="im">import</span> solve_discrete_are, expm</span>
<span id="cb13-6"><a></a><span class="im">from</span> scipy.signal <span class="im">import</span> cont2discrete</span>
<span id="cb13-7"><a></a><span class="im">import</span> cvxpy <span class="im">as</span> cp <span class="co"># Requires cvxpy and a solver like OSQP</span></span>
<span id="cb13-8"><a></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb13-9"><a></a><span class="im">import</span> time</span>
<span id="cb13-10"><a></a></span>
<span id="cb13-11"><a></a><span class="co"># print("--- Running Scenario 3: MPC (Nonzero Setpoint, Damped System) ---")</span></span>
<span id="cb13-12"><a></a></span>
<span id="cb13-13"><a></a><span class="co"># --- 1. System Definition ---</span></span>
<span id="cb13-14"><a></a>c_damping <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb13-15"><a></a>Ac <span class="op">=</span> np.array([[<span class="fl">0.</span>, <span class="fl">1.</span>], [<span class="fl">1.</span>, <span class="op">-</span>c_damping]])</span>
<span id="cb13-16"><a></a>Bc <span class="op">=</span> np.array([[<span class="fl">0.</span>], [<span class="fl">1.</span>]])</span>
<span id="cb13-17"><a></a>n_states <span class="op">=</span> Ac.shape[<span class="dv">0</span>]</span>
<span id="cb13-18"><a></a>m_inputs <span class="op">=</span> Bc.shape[<span class="dv">1</span>]</span>
<span id="cb13-19"><a></a><span class="kw">def</span> system_ode(t, x, u, Ac_mat, Bc_mat):</span>
<span id="cb13-20"><a></a>    u_val <span class="op">=</span> u <span class="cf">if</span> np.isscalar(u) <span class="cf">else</span> u[<span class="dv">0</span>]</span>
<span id="cb13-21"><a></a>    dxdt <span class="op">=</span> Ac_mat <span class="op">@</span> x <span class="op">+</span> Bc_mat <span class="op">@</span> np.array([u_val])</span>
<span id="cb13-22"><a></a>    <span class="cf">return</span> dxdt.flatten()</span>
<span id="cb13-23"><a></a></span>
<span id="cb13-24"><a></a><span class="co"># --- 2. Discretization ---</span></span>
<span id="cb13-25"><a></a>Ts <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb13-26"><a></a>Ad, Bd, _, _, _ <span class="op">=</span> cont2discrete((Ac, Bc, np.eye(n_states), np.zeros((n_states, m_inputs))), Ts, method<span class="op">=</span><span class="st">'zoh'</span>)</span>
<span id="cb13-27"><a></a><span class="co"># print("--- Discrete Model ---")</span></span>
<span id="cb13-28"><a></a><span class="co"># print(f"Ad = \n{Ad}")</span></span>
<span id="cb13-29"><a></a><span class="co"># print(f"Bd = \n{Bd}")</span></span>
<span id="cb13-30"><a></a></span>
<span id="cb13-31"><a></a><span class="co"># --- 3. Setpoint ---</span></span>
<span id="cb13-32"><a></a>x_ref <span class="op">=</span> np.array([[<span class="fl">1.0</span>], [<span class="fl">0.0</span>]]) <span class="co"># Target state y=1, y_dot=0 (use column vector shape)</span></span>
<span id="cb13-33"><a></a><span class="cf">try</span>:</span>
<span id="cb13-34"><a></a>    u_ref_vec <span class="op">=</span> np.linalg.pinv(Bd) <span class="op">@</span> (np.eye(n_states) <span class="op">-</span> Ad) <span class="op">@</span> x_ref</span>
<span id="cb13-35"><a></a>    u_ref <span class="op">=</span> u_ref_vec[<span class="dv">0</span>,<span class="dv">0</span>] <span class="co"># Extract scalar</span></span>
<span id="cb13-36"><a></a>    <span class="co"># print(f"Setpoint: x_ref = {x_ref.T}, requires discrete u_ref = {u_ref:.3f} (cont. u_ref=-1.0)")</span></span>
<span id="cb13-37"><a></a><span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb13-38"><a></a>    <span class="bu">print</span>(<span class="ss">f"Could not calculate discrete u_ref: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">. Using continuous u_ref."</span>)</span>
<span id="cb13-39"><a></a>    u_ref <span class="op">=</span> <span class="op">-</span>x_ref[<span class="dv">0</span>,<span class="dv">0</span>] <span class="co"># Use continuous calculation</span></span>
<span id="cb13-40"><a></a></span>
<span id="cb13-41"><a></a><span class="co"># --- 4. MPC Setup ---</span></span>
<span id="cb13-42"><a></a>P <span class="op">=</span> <span class="dv">30</span> <span class="co"># Prediction Horizon</span></span>
<span id="cb13-43"><a></a><span class="co"># Use same base weights as LQR example, but consider tuning R_mpc</span></span>
<span id="cb13-44"><a></a>Q_mpc <span class="op">=</span> np.diag([<span class="fl">1.0</span>, <span class="fl">0.1</span>])</span>
<span id="cb13-45"><a></a><span class="co"># R_mpc = np.array([[0.01]]) # Original aggressive LQR R</span></span>
<span id="cb13-46"><a></a>R_mpc <span class="op">=</span> np.array([[<span class="fl">0.1</span>]]) <span class="co"># Use less aggressive R for MPC? Try this.</span></span>
<span id="cb13-47"><a></a><span class="co"># Calculate terminal weight Qf from DARE solution S using MPC weights</span></span>
<span id="cb13-48"><a></a><span class="cf">try</span>:</span>
<span id="cb13-49"><a></a>    S <span class="op">=</span> solve_discrete_are(Ad, Bd, Q_mpc, R_mpc)</span>
<span id="cb13-50"><a></a>    Qf_mpc <span class="op">=</span> S</span>
<span id="cb13-51"><a></a>    <span class="co"># print(f"Using terminal weight Qf=S based on MPC Q/R: \n{Qf_mpc}")</span></span>
<span id="cb13-52"><a></a><span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb13-53"><a></a>    <span class="bu">print</span>(<span class="ss">f"DARE solve failed (</span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">), using Qf=Q"</span>)<span class="op">;</span> Qf_mpc <span class="op">=</span> Q_mpc</span>
<span id="cb13-54"><a></a></span>
<span id="cb13-55"><a></a><span class="co"># Constraints</span></span>
<span id="cb13-56"><a></a>u_min <span class="op">=</span> <span class="op">-</span><span class="fl">2.5</span></span>
<span id="cb13-57"><a></a>u_max <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb13-58"><a></a><span class="bu">print</span>(<span class="ss">f"Control Limits: [</span><span class="sc">{</span>u_min<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>u_max<span class="sc">}</span><span class="ss">]"</span>)</span>
<span id="cb13-59"><a></a></span>
<span id="cb13-60"><a></a><span class="co"># --- 5. CVXPY Optimization Problem Setup ---</span></span>
<span id="cb13-61"><a></a>U <span class="op">=</span> cp.Variable((m_inputs, P), name<span class="op">=</span><span class="st">'U'</span>)</span>
<span id="cb13-62"><a></a>x_k_param <span class="op">=</span> cp.Parameter(n_states, name<span class="op">=</span><span class="st">'x_k_param'</span>) <span class="co"># Current state parameter</span></span>
<span id="cb13-63"><a></a>cost <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb13-64"><a></a>constraints <span class="op">=</span> []</span>
<span id="cb13-65"><a></a>x_pred <span class="op">=</span> x_k_param <span class="co"># Use parameter for current state</span></span>
<span id="cb13-66"><a></a></span>
<span id="cb13-67"><a></a><span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(P):</span>
<span id="cb13-68"><a></a>    <span class="co"># Penalize deviation from reference state &amp; absolute control input</span></span>
<span id="cb13-69"><a></a>    cost <span class="op">+=</span> cp.quad_form(x_pred <span class="op">-</span> x_ref.flatten(), Q_mpc) <span class="op">+</span> cp.quad_form(U[:, t], R_mpc)</span>
<span id="cb13-70"><a></a>    x_next <span class="op">=</span> Ad <span class="op">@</span> x_pred <span class="op">+</span> Bd <span class="op">@</span> U[:, t]</span>
<span id="cb13-71"><a></a>    constraints <span class="op">+=</span> [U[:, t] <span class="op">&gt;=</span> u_min, U[:, t] <span class="op">&lt;=</span> u_max]</span>
<span id="cb13-72"><a></a>    x_pred <span class="op">=</span> x_next</span>
<span id="cb13-73"><a></a><span class="co"># Terminal cost penalizes deviation from x_ref</span></span>
<span id="cb13-74"><a></a>cost <span class="op">+=</span> cp.quad_form(x_pred <span class="op">-</span> x_ref.flatten(), Qf_mpc)</span>
<span id="cb13-75"><a></a></span>
<span id="cb13-76"><a></a>objective <span class="op">=</span> cp.Minimize(cost)</span>
<span id="cb13-77"><a></a>problem <span class="op">=</span> cp.Problem(objective, constraints)</span>
<span id="cb13-78"><a></a><span class="bu">print</span>(<span class="st">"MPC CVXPY Problem defined."</span>)</span>
<span id="cb13-79"><a></a></span>
<span id="cb13-80"><a></a><span class="co"># --- 6. Simulation Setup ---</span></span>
<span id="cb13-81"><a></a>t_start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-82"><a></a>t_end <span class="op">=</span> <span class="fl">6.0</span></span>
<span id="cb13-83"><a></a>n_steps <span class="op">=</span> <span class="bu">int</span>(t_end <span class="op">/</span> Ts)</span>
<span id="cb13-84"><a></a>x0 <span class="op">=</span> np.array([<span class="fl">0.0</span>, <span class="fl">0.0</span>]) <span class="co"># Initial condition</span></span>
<span id="cb13-85"><a></a></span>
<span id="cb13-86"><a></a><span class="co"># --- Helper function for interval simulation ---</span></span>
<span id="cb13-87"><a></a><span class="kw">def</span> simulate_interval(ode_func, t_start, x_start, duration, control_val):</span>
<span id="cb13-88"><a></a>    t_eval_interval <span class="op">=</span> [t_start <span class="op">+</span> duration]</span>
<span id="cb13-89"><a></a>    sol_interval <span class="op">=</span> solve_ivp(</span>
<span id="cb13-90"><a></a>        ode_func, (t_start, t_start <span class="op">+</span> duration), x_start, method<span class="op">=</span><span class="st">'RK45'</span>,</span>
<span id="cb13-91"><a></a>        t_eval<span class="op">=</span>t_eval_interval, args<span class="op">=</span>(control_val,)</span>
<span id="cb13-92"><a></a>    )</span>
<span id="cb13-93"><a></a>    <span class="cf">if</span> sol_interval.status <span class="op">!=</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="va">None</span>, <span class="va">False</span></span>
<span id="cb13-94"><a></a>    <span class="cf">return</span> sol_interval.y[:, <span class="op">-</span><span class="dv">1</span>], <span class="va">True</span></span>
<span id="cb13-95"><a></a></span>
<span id="cb13-96"><a></a><span class="co"># --- 7. Simulation Loop ---</span></span>
<span id="cb13-97"><a></a>t_history <span class="op">=</span> [t_start]</span>
<span id="cb13-98"><a></a>x_history <span class="op">=</span> [x0]</span>
<span id="cb13-99"><a></a>u_history <span class="op">=</span> [] <span class="co"># Applied MPC control</span></span>
<span id="cb13-100"><a></a>current_t <span class="op">=</span> t_start</span>
<span id="cb13-101"><a></a>current_x <span class="op">=</span> x0.copy()</span>
<span id="cb13-102"><a></a>success_run <span class="op">=</span> <span class="va">True</span></span>
<span id="cb13-103"><a></a>infeasibility_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-104"><a></a></span>
<span id="cb13-105"><a></a>start_sim_time <span class="op">=</span> time.time()</span>
<span id="cb13-106"><a></a><span class="co"># print("Running simulation...")</span></span>
<span id="cb13-107"><a></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb13-108"><a></a>    x_k_param.value <span class="op">=</span> current_x <span class="co"># Update parameter</span></span>
<span id="cb13-109"><a></a>    u_k <span class="op">=</span> u_ref <span class="co"># Default if solver fails</span></span>
<span id="cb13-110"><a></a>    <span class="cf">try</span>:</span>
<span id="cb13-111"><a></a>        problem.solve(solver<span class="op">=</span>cp.OSQP, warm_start<span class="op">=</span><span class="va">True</span>, verbose<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb13-112"><a></a>        <span class="cf">if</span> problem.status <span class="op">==</span> cp.OPTIMAL <span class="kw">or</span> problem.status <span class="op">==</span> cp.OPTIMAL_INACCURATE:</span>
<span id="cb13-113"><a></a>            u_k <span class="op">=</span> U.value[<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb13-114"><a></a>        <span class="cf">else</span>:</span>
<span id="cb13-115"><a></a>            <span class="bu">print</span>(<span class="ss">f"MPC Warning: Solver status </span><span class="sc">{</span>problem<span class="sc">.</span>status<span class="sc">}</span><span class="ss"> at k=</span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb13-116"><a></a>            infeasibility_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb13-117"><a></a>            <span class="cf">if</span> U.value <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>: u_k <span class="op">=</span> U.value[<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb13-118"><a></a>            <span class="cf">if</span> problem.status <span class="op">==</span> cp.INFEASIBLE:</span>
<span id="cb13-119"><a></a>                 <span class="bu">print</span>(<span class="st">"MPC Problem is infeasible. Stopping."</span>)<span class="op">;</span> success_run <span class="op">=</span> <span class="va">False</span><span class="op">;</span> <span class="cf">break</span></span>
<span id="cb13-120"><a></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb13-121"><a></a>        <span class="bu">print</span>(<span class="ss">f"MPC Solver failed at k=</span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)<span class="op">;</span> infeasibility_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb13-122"><a></a></span>
<span id="cb13-123"><a></a>    <span class="co"># Apply saturation as safety/clip numerical tolerances</span></span>
<span id="cb13-124"><a></a>    u_k_sat <span class="op">=</span> np.clip(u_k, u_min, u_max)</span>
<span id="cb13-125"><a></a>    u_history.append(u_k_sat)</span>
<span id="cb13-126"><a></a></span>
<span id="cb13-127"><a></a>    <span class="kw">def</span> ode_mpc_interval(t, y, u_val):</span>
<span id="cb13-128"><a></a>        <span class="cf">return</span> system_ode(t, y, u_val, Ac, Bc)</span>
<span id="cb13-129"><a></a></span>
<span id="cb13-130"><a></a>    next_x, success <span class="op">=</span> simulate_interval(ode_mpc_interval, current_t, current_x, Ts, u_k_sat)</span>
<span id="cb13-131"><a></a></span>
<span id="cb13-132"><a></a>    <span class="cf">if</span> <span class="kw">not</span> success:</span>
<span id="cb13-133"><a></a>        <span class="bu">print</span>(<span class="ss">f"ODE solver failed at t=</span><span class="sc">{</span>current_t<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb13-134"><a></a>        success_run <span class="op">=</span> <span class="va">False</span><span class="op">;</span> <span class="cf">break</span></span>
<span id="cb13-135"><a></a></span>
<span id="cb13-136"><a></a>    current_t <span class="op">+=</span> Ts</span>
<span id="cb13-137"><a></a>    current_x <span class="op">=</span> next_x</span>
<span id="cb13-138"><a></a>    t_history.append(current_t)</span>
<span id="cb13-139"><a></a>    x_history.append(current_x.copy())</span>
<span id="cb13-140"><a></a></span>
<span id="cb13-141"><a></a>    <span class="cf">if</span> np.<span class="bu">max</span>(np.<span class="bu">abs</span>(current_x)) <span class="op">&gt;</span> <span class="dv">100</span>: <span class="co"># Divergence check</span></span>
<span id="cb13-142"><a></a>        <span class="bu">print</span>(<span class="ss">f"State diverging excessively at t=</span><span class="sc">{</span>current_t<span class="sc">:.2f}</span><span class="ss">. Stopping."</span>)</span>
<span id="cb13-143"><a></a>        success_run <span class="op">=</span> <span class="va">False</span><span class="op">;</span> <span class="cf">break</span></span>
<span id="cb13-144"><a></a></span>
<span id="cb13-145"><a></a><span class="bu">print</span>(<span class="ss">f"MPC Simulation loop time: </span><span class="sc">{</span>time<span class="sc">.</span>time() <span class="op">-</span> start_sim_time<span class="sc">:.2f}</span><span class="ss"> s"</span>)</span>
<span id="cb13-146"><a></a><span class="cf">if</span> infeasibility_count <span class="op">&gt;</span> <span class="dv">0</span>: <span class="bu">print</span>(<span class="ss">f"Warning: MPC Solver non-optimal status </span><span class="sc">{</span>infeasibility_count<span class="sc">}</span><span class="ss"> times."</span>)</span>
<span id="cb13-147"><a></a></span>
<span id="cb13-148"><a></a><span class="co"># --- 8. Plotting ---</span></span>
<span id="cb13-149"><a></a><span class="cf">if</span> success_run:</span>
<span id="cb13-150"><a></a>    t_history <span class="op">=</span> np.array(t_history)</span>
<span id="cb13-151"><a></a>    x_history <span class="op">=</span> np.array(x_history).T</span>
<span id="cb13-152"><a></a>    u_history <span class="op">=</span> np.array(u_history)</span>
<span id="cb13-153"><a></a>    n_plot <span class="op">=</span> <span class="bu">len</span>(u_history)</span>
<span id="cb13-154"><a></a></span>
<span id="cb13-155"><a></a>    <span class="co"># Use consistent plot limits from Block 1 &amp; 2 (or adjust)</span></span>
<span id="cb13-156"><a></a>    xlims <span class="op">=</span> (t_start, t_end)</span>
<span id="cb13-157"><a></a>    ylims_x1 <span class="op">=</span> (<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">1.5</span>)</span>
<span id="cb13-158"><a></a>    ylims_x2 <span class="op">=</span> (<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">1.5</span>)</span>
<span id="cb13-159"><a></a>    ylims_u <span class="op">=</span> (<span class="op">-</span><span class="dv">4</span>, <span class="dv">1</span>) <span class="co"># Use same limits</span></span>
<span id="cb13-160"><a></a></span>
<span id="cb13-161"><a></a>    plt.figure(<span class="st">"MPC (Nonzero Setpoint, Damped)"</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">9</span>))</span>
<span id="cb13-162"><a></a>    plt.rcParams.update({<span class="st">'font.size'</span>: <span class="dv">12</span>})</span>
<span id="cb13-163"><a></a></span>
<span id="cb13-164"><a></a>    plt.subplot(<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb13-165"><a></a>    plt.plot(t_history[:n_plot<span class="op">+</span><span class="dv">1</span>], x_history[<span class="dv">0</span>,:n_plot<span class="op">+</span><span class="dv">1</span>], label<span class="op">=</span><span class="st">'$x_1$ (y)'</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb13-166"><a></a>    plt.axhline(x_ref[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, label<span class="op">=</span><span class="ss">f'Setpoint $x_1=</span><span class="sc">{</span>x_ref[<span class="dv">0</span>,<span class="dv">0</span>]<span class="sc">}</span><span class="ss">$'</span>)</span>
<span id="cb13-167"><a></a>    plt.title(<span class="ss">f'MPC Response (Setpoint x=[</span><span class="sc">{</span>x_ref[<span class="dv">0</span>,<span class="dv">0</span>]<span class="sc">}</span><span class="ss">,</span><span class="sc">{</span>x_ref[<span class="dv">1</span>,<span class="dv">0</span>]<span class="sc">}</span><span class="ss">]^T, u limits=[</span><span class="sc">{</span>u_min<span class="sc">}</span><span class="ss">,</span><span class="sc">{</span>u_max<span class="sc">}</span><span class="ss">], P=</span><span class="sc">{</span>P<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb13-168"><a></a>    plt.ylabel(<span class="st">'Position $x_1$'</span>)</span>
<span id="cb13-169"><a></a>    plt.ylim(ylims_x1)<span class="op">;</span> plt.xlim(xlims)<span class="op">;</span> plt.grid(<span class="va">True</span>)<span class="op">;</span> plt.legend()</span>
<span id="cb13-170"><a></a></span>
<span id="cb13-171"><a></a>    plt.subplot(<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb13-172"><a></a>    plt.plot(t_history[:n_plot<span class="op">+</span><span class="dv">1</span>], x_history[<span class="dv">1</span>,:n_plot<span class="op">+</span><span class="dv">1</span>], label<span class="op">=</span><span class="st">'$x_2$ (dy/dt)'</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb13-173"><a></a>    plt.axhline(x_ref[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, label<span class="op">=</span><span class="ss">f'Setpoint $x_2=</span><span class="sc">{</span>x_ref[<span class="dv">1</span>,<span class="dv">0</span>]<span class="sc">}</span><span class="ss">$'</span>)</span>
<span id="cb13-174"><a></a>    plt.ylabel(<span class="st">'Velocity $x_2$'</span>)</span>
<span id="cb13-175"><a></a>    plt.ylim(ylims_x2)<span class="op">;</span> plt.xlim(xlims)<span class="op">;</span> plt.grid(<span class="va">True</span>)<span class="op">;</span> plt.legend()</span>
<span id="cb13-176"><a></a></span>
<span id="cb13-177"><a></a>    plt.subplot(<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb13-178"><a></a>    plt.step(t_history[:n_plot], u_history[:n_plot], where<span class="op">=</span><span class="st">'post'</span>, label<span class="op">=</span><span class="st">'Applied MPC u[k]'</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb13-179"><a></a>    plt.axhline(u_ref, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, label<span class="op">=</span><span class="ss">f'Steady-State u=</span><span class="sc">{</span>u_ref<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb13-180"><a></a>    plt.axhline(u_max, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, label<span class="op">=</span><span class="st">'Limit'</span>)</span>
<span id="cb13-181"><a></a>    plt.axhline(u_min, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">':'</span>)</span>
<span id="cb13-182"><a></a>    plt.ylabel(<span class="st">'Control Input u'</span>)</span>
<span id="cb13-183"><a></a>    plt.xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb13-184"><a></a>    plt.ylim(ylims_u)<span class="op">;</span> plt.xlim(xlims)<span class="op">;</span> plt.grid(<span class="va">True</span>)<span class="op">;</span> plt.legend()</span>
<span id="cb13-185"><a></a></span>
<span id="cb13-186"><a></a>    plt.tight_layout()</span>
<span id="cb13-187"><a></a>    plt.show()</span>
<span id="cb13-188"><a></a><span class="cf">else</span>:</span>
<span id="cb13-189"><a></a>    <span class="bu">print</span>(<span class="st">"Simulation failed, not plotting."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div><div class="column">
<div class="cell-output cell-output-stdout">
<pre><code>Control Limits: [-2.5, 0.5]
MPC CVXPY Problem defined.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>MPC Simulation loop time: 18.55 s</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture9_files/figure-revealjs/cell-9-output-3.png"></p>
</figure>
</div>
</div>
</div></div>
</div>
</div>
</div>
</section></section>
<section>
<section id="model-predictive-control-mpc" class="title-slide slide level1 center">
<h1>Model Predictive Control (MPC)</h1>
<p>MPC is a powerful control strategy that uses an <strong>optimization problem</strong> to determine the control input at each time step. It is particularly useful for systems with constraints and nonlinearities.</p>
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Tip</strong></p>
</div>
<div class="callout-content">
<p>While LQR solves the infinite-horizon optimal control problem, MPC solves a <strong>finite-horizon</strong> optimization problem at each time step (this horizon is MPC’s <strong>prediction horizon</strong>, i.e.&nbsp;how many steps ahead it looks).</p>
</div>
</div>
</div>
</section>
<section id="how-mpc-works" class="slide level2 scrollable">
<h2>How MPC Works</h2>
<ol type="1">
<li class="fragment">MPC solves an <strong>optimization problem</strong> at each time step to find the optimal control sequence over a finite horizon.</li>
<li class="fragment">The first control input of the optimal sequence is applied to the system.</li>
<li class="fragment">The process is repeated at the next time step, using the current state as the new initial condition.</li>
</ol>
<div class="fragment">
<p><strong>MPC vs LQR:</strong></p>
<ul>
<li class="fragment">MPC handles <strong>constraints</strong> (e.g.&nbsp;input saturation, <strong>state constraints</strong>, rate of change limits, etc).</li>
<li class="fragment">MPC is more complex and computationally intensive than LQR.</li>
<li class="fragment">MPC’s performance depends on the accuracy of the system model.</li>
</ul>


</div>
</section></section>

    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<div class="footer footer-default">

</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="../site_libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="../site_libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-chalkboard/plugin.js"></script>
  <script src="../site_libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="../site_libs/revealjs/plugin/notes/notes.js"></script>
  <script src="../site_libs/revealjs/plugin/search/search.js"></script>
  <script src="../site_libs/revealjs/plugin/zoom/zoom.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleChalkboard(event)\"><kbd>b</kbd> Toggle Chalkboard</a></li>\n<li class=\"slide-tool-item\" data-item=\"6\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleNotesCanvas(event)\"><kbd>c</kbd> Toggle Notes Canvas</a></li>\n<li class=\"slide-tool-item\" data-item=\"7\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.downloadDrawings(event)\"><kbd>d</kbd> Download Drawings</a></li>\n<li class=\"slide-tool-item\" data-item=\"8\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'chalkboard': {"buttons":true},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,

        height: 720,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, RevealChalkboard, QuartoSupport,

          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <div class="slide-footer">

        <img src="../qut_logo.jpg" alt="QUT Logo" class="qut-logo"> 

        <span class="course-code">

          <!-- <a href="../index.html">EGH445 Modern Control</a> -->

          EGH445 Modern Control

        </span>

      </div>
    <script>

    // custom.js

    

    // Variable to store the last seen H1 title (Section Title)

    let currentSectionTitle = "";

    // Variable to store the main Lecture Title (will be set on ready)

    let currentLectureTitle = "";

    // Variable to store the last seen H2 title (Slide Title)

    let currentSlideTitle = "";

    

    function updateHeaderContent(currentSlide) {

      let headerLeft = document.getElementById('header-left');

      let headerRight = document.getElementById('header-right');

      let subHeaderContainer = document.getElementById('sub-header-container');

      let subHeaderTitle = document.getElementById('sub-header-title');

    

      // --- Check for data-attributes first ---

      let slideDataHeaderLeft = currentSlide.dataset.headerLeft;

      let slideDataHeaderRight = currentSlide.dataset.headerRight;

    

      // --- Left Header (Lecture Title / Override) ---

      if (headerLeft) {

        if (slideDataHeaderLeft !== undefined) {

          // Use attribute value if present on the slide

          headerLeft.innerText = slideDataHeaderLeft;

        } else {

          // Otherwise, use the stored lecture title

          headerLeft.innerText = currentLectureTitle;

        }

      }

    

      // --- Right Header (Section Title / Override) ---

      let h1Element = currentSlide.querySelector('h1');

      let useH1Logic = true; // Flag to determine if we use H1 logic

    

      if (headerRight) {

        if (slideDataHeaderRight !== undefined) {

          // Use attribute value if present on the slide

          headerRight.innerText = slideDataHeaderRight;

          useH1Logic = false; // Don't use H1 logic if attribute is set

        }

      }

    

      // --- H1 Logic (Only if data-header-right wasn't used) ---

      if (useH1Logic) {

        if (h1Element) {

          // H1 FOUND (Section Title Slide)

          currentSectionTitle = h1Element.innerText.trim();

          if (headerRight) {

              headerRight.innerText = currentSectionTitle;

          }

          if (subHeaderContainer) {

              subHeaderContainer.style.display = 'none'; // Hide sub-header on H1 slides

          }

        } else {

          // NO H1 FOUND (Regular Slide)

           if (headerRight) {

              headerRight.innerText = currentSectionTitle; // Use stored section title

          }

          if (subHeaderContainer) {

              subHeaderContainer.style.display = 'block'; // Show sub-header on regular slides

          }

        }

      } else {

        // If data-header-right was used, decide sub-header visibility

        // Option 1: Hide sub-header if data-header-right is present

        if (subHeaderContainer) {

            subHeaderContainer.style.display = 'none';

        }

        // Option 2: Keep sub-header logic based on H1 presence (even if H1 text isn't used for headerRight)

        // if (h1Element && subHeaderContainer) { subHeaderContainer.style.display = 'none'; }

        // else if (subHeaderContainer) { subHeaderContainer.style.display = 'block'; }

      }

    

      // --- Sub-Header Title (H2) ---

      let h2Element = currentSlide.querySelector('h2');

      // Only update currentSlideTitle when an H2 is found AND has non-empty text

      if (h2Element && !currentSlide.classList.contains('title-slide-custom') && h2Element.innerText.trim() !== "") {

          currentSlideTitle = h2Element.innerText.trim(); // Store the H2 text when found

      }

      // Always apply the currentSlideTitle (whether it was just updated or is persisting from a previous slide)

      if (subHeaderTitle && currentSlideTitle !== "") {

        subHeaderTitle.innerText = currentSlideTitle;

      }

    }

    

    // --- Reveal.on('ready', ...) ---

    Reveal.on('ready', event => {

      let headerLeft = document.getElementById('header-left');

      let firstSlide = event.currentSlide;

      // Use H1 from .title-block on the *very first slide* to set the default lecture title

      let titleElement = document.querySelector('.reveal .slides section:first-of-type .title-block h1');

    

      if (titleElement) {

          currentLectureTitle = titleElement.innerText.trim();

      } else {

          // Fallback logic...

          let docTitle = document.title;

          if (docTitle && docTitle.includes('|')) {

            currentLectureTitle = docTitle.split('|')[0].trim();

          } else if (docTitle) {

            currentLectureTitle = docTitle.trim();

          } else {

            currentLectureTitle = "Lecture";

          }

      }

      

      // Initialize currentSlideTitle from the first slide if it has an H2 with non-empty text

      let firstH2 = firstSlide.querySelector('h2');

      if (firstH2 && !firstSlide.classList.contains('title-slide-custom') && firstH2.innerText.trim() !== "") {

        currentSlideTitle = firstH2.innerText.trim();

      }

    

      // --- Run initial update ---

      // This will now check attributes on the first slide

      updateHeaderContent(firstSlide);

    });

    

    // Add listener for when the slide changes

    Reveal.on('slidechanged', event => {

      updateHeaderContent(event.currentSlide);

    });

    

    // Add listener for when a fragment is shown

    Reveal.on('fragmentshown', event => {

      // event.fragment is the DOM element of the fragment that was shown

      let fragment = event.fragment;

    

      // Find the closest ancestor element with the class 'scrollable'

      let scrollableContainer = fragment.closest('.scrollable');

    

      // If the fragment is inside a .scrollable container

      if (scrollableContainer) {

        // Scroll the container to bring the fragment into view

        // Options like 'smooth', 'center' can be adjusted

        fragment.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

      }

    });

    </script>
    <script id="quarto-html-after-body" type="application/javascript">
      window.document.addEventListener("DOMContentLoaded", function (event) {
        const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
        tabsets.forEach(function(tabset) {
          const tabby = new Tabby('#' + tabset.id);
        });
        const isCodeAnnotation = (el) => {
          for (const clz of el.classList) {
            if (clz.startsWith('code-annotation-')) {                     
              return true;
            }
          }
          return false;
        }
        const onCopySuccess = function(e) {
          // button target
          const button = e.trigger;
          // don't keep focus
          button.blur();
          // flash "checked"
          button.classList.add('code-copy-button-checked');
          var currentTitle = button.getAttribute("title");
          button.setAttribute("title", "Copied!");
          let tooltip;
          if (window.bootstrap) {
            button.setAttribute("data-bs-toggle", "tooltip");
            button.setAttribute("data-bs-placement", "left");
            button.setAttribute("data-bs-title", "Copied!");
            tooltip = new bootstrap.Tooltip(button, 
              { trigger: "manual", 
                customClass: "code-copy-button-tooltip",
                offset: [0, -8]});
            tooltip.show();    
          }
          setTimeout(function() {
            if (tooltip) {
              tooltip.hide();
              button.removeAttribute("data-bs-title");
              button.removeAttribute("data-bs-toggle");
              button.removeAttribute("data-bs-placement");
            }
            button.setAttribute("title", currentTitle);
            button.classList.remove('code-copy-button-checked');
          }, 1000);
          // clear code selection
          e.clearSelection();
        }
        const getTextToCopy = function(trigger) {
            const codeEl = trigger.previousElementSibling.cloneNode(true);
            for (const childEl of codeEl.children) {
              if (isCodeAnnotation(childEl)) {
                childEl.remove();
              }
            }
            return codeEl.innerText;
        }
        const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
          text: getTextToCopy
        });
        clipboard.on('success', onCopySuccess);
        if (window.document.getElementById('quarto-embedded-source-code-modal')) {
          const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
            text: getTextToCopy,
            container: window.document.getElementById('quarto-embedded-source-code-modal')
          });
          clipboardModal.on('success', onCopySuccess);
        }
          var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
          var mailtoRegex = new RegExp(/^mailto:/);
            var filterRegex = new RegExp('/' + window.location.host + '/');
          var isInternal = (href) => {
              return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
          }
          // Inspect non-navigation links and adorn them if external
         var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
          for (var i=0; i<links.length; i++) {
            const link = links[i];
            if (!isInternal(link.href)) {
              // undo the damage that might have been done by quarto-nav.js in the case of
              // links that we want to consider external
              if (link.dataset.originalHref !== undefined) {
                link.href = link.dataset.originalHref;
              }
            }
          }
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
          const config = {
            allowHTML: true,
            maxWidth: 500,
            delay: 100,
            arrow: false,
            appendTo: function(el) {
                return el.closest('section.slide') || el.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'light-border',
            placement: 'bottom-start',
          };
          if (contentFn) {
            config.content = contentFn;
          }
          if (onTriggerFn) {
            config.onTrigger = onTriggerFn;
          }
          if (onUntriggerFn) {
            config.onUntrigger = onUntriggerFn;
          }
            config['offset'] = [0,0];
            config['maxWidth'] = 700;
          window.tippy(el, config); 
        }
        const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
        for (var i=0; i<noterefs.length; i++) {
          const ref = noterefs[i];
          tippyHover(ref, function() {
            // use id or data attribute instead here
            let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
            try { href = new URL(href).hash; } catch {}
            const id = href.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note) {
              return note.innerHTML;
            } else {
              return "";
            }
          });
        }
        const findCites = (el) => {
          const parentEl = el.parentElement;
          if (parentEl) {
            const cites = parentEl.dataset.cites;
            if (cites) {
              return {
                el,
                cites: cites.split(' ')
              };
            } else {
              return findCites(el.parentElement)
            }
          } else {
            return undefined;
          }
        };
        var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i=0; i<bibliorefs.length; i++) {
          const ref = bibliorefs[i];
          const citeInfo = findCites(ref);
          if (citeInfo) {
            tippyHover(citeInfo.el, function() {
              var popup = window.document.createElement('div');
              citeInfo.cites.forEach(function(cite) {
                var citeDiv = window.document.createElement('div');
                citeDiv.classList.add('hanging-indent');
                citeDiv.classList.add('csl-entry');
                var biblioDiv = window.document.getElementById('ref-' + cite);
                if (biblioDiv) {
                  citeDiv.innerHTML = biblioDiv.innerHTML;
                }
                popup.appendChild(citeDiv);
              });
              return popup.innerHTML;
            });
          }
        }
      });
      </script>
    

</body></html>